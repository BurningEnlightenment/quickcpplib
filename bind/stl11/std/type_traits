/* This is an automatically generated bindings file. Don't modify it! */
#if !defined(BOOST_STL11_TYPE_TRAITS_MAP_NAMESPACE_BEGIN) || !defined(BOOST_STL11_TYPE_TRAITS_MAP_NAMESPACE_END)
#error You need to define BOOST_STL11_TYPE_TRAITS_MAP_NAMESPACE_BEGIN and BOOST_STL11_TYPE_TRAITS_MAP_NAMESPACE_END to use this header file
#endif
#include <type_traits>
BOOST_STL11_TYPE_TRAITS_MAP_NAMESPACE_BEGIN
extern const char *boost_local_bind_in;
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_COMMON_TYPE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_COMMON_TYPE
#else
template<class... _Tp> using common_type = std::common_type<_Tp...>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_ENABLE_IF
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_ENABLE_IF
#else
template<bool _0, class _Tp> using enable_if = std::enable_if<_0, _Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_POINTER
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_POINTER
#else
template<class _Tp> using add_pointer = std::add_pointer<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_ALIGNED_STORAGE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_ALIGNED_STORAGE
#else
template<std::size_t _0, std::size_t _1> using aligned_storage = std::aligned_storage<_0, _1>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_EXTENT
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_EXTENT
#else
template<class _Tp> using remove_extent = std::remove_extent<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_MAKE_SIGNED
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_MAKE_SIGNED
#else
template<class _Tp> using make_signed = std::make_signed<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_MAKE_UNSIGNED
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_MAKE_UNSIGNED
#else
template<class _Tp> using make_unsigned = std::make_unsigned<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_CONST
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_CONST
#else
template<class _Tp> using add_const = std::add_const<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_VOLATILE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_VOLATILE
#else
template<class _Tp> using remove_volatile = std::remove_volatile<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_CONVERTIBLE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_CONVERTIBLE
#else
template<class _From, class _To> using is_convertible = std::is_convertible<_From, _To>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_HAS_VIRTUAL_DESTRUCTOR
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_HAS_VIRTUAL_DESTRUCTOR
#else
template<class _Tp> using has_virtual_destructor = std::has_virtual_destructor<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_HAS_TRIVIAL_COPY_CONSTRUCTOR
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_HAS_TRIVIAL_COPY_CONSTRUCTOR
#else
template<class _Tp> using has_trivial_copy_constructor = std::has_trivial_copy_constructor<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_NOTHROW_MOVE_ASSIGNABLE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_NOTHROW_MOVE_ASSIGNABLE
#else
template<class _Tp> using is_nothrow_move_assignable = std::is_nothrow_move_assignable<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_CV
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_CV
#else
template<class _Tp> using add_cv = std::add_cv<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_POINTER
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_POINTER
#else
template<class _Tp> using remove_pointer = std::remove_pointer<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_BASE_OF
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_BASE_OF
#else
template<class _Base, class _Derived> using is_base_of = std::is_base_of<_Base, _Derived>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_BASE_OF
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_BASE_OF
#else
template<class type_parameter_0_0, class type_parameter_0_1> using is_base_of = std::is_base_of<type_parameter_0_0, type_parameter_0_1>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_SAME
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_SAME
#else
template<class type_parameter_0_0, class type_parameter_0_1> using is_same = std::is_same<type_parameter_0_0, type_parameter_0_1>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_CLASS
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_CLASS
#else
template<class _Tp> using is_class = std::is_class<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_ENUM
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_ENUM
#else
template<class _Tp> using is_enum = std::is_enum<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_MEMBER_FUNCTION_POINTER
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_MEMBER_FUNCTION_POINTER
#else
template<class _Tp> using is_member_function_pointer = std::is_member_function_pointer<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_LVALUE_REFERENCE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_LVALUE_REFERENCE
#else
template<class type_parameter_0_0> using is_lvalue_reference = std::is_lvalue_reference<type_parameter_0_0>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_POINTER
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_POINTER
#else
template<class _Tp> using is_pointer = std::is_pointer<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_EMPTY
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_EMPTY
#else
template<class _Tp> using is_empty = std::is_empty<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_OBJECT
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_OBJECT
#else
template<class _Tp> using is_object = std::is_object<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_CONST
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_CONST
#else
template<class type_parameter_0_0> using is_const = std::is_const<type_parameter_0_0>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_RVALUE_REFERENCE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_RVALUE_REFERENCE
#else
template<class type_parameter_0_0> using is_rvalue_reference = std::is_rvalue_reference<type_parameter_0_0>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_ARRAY
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_ARRAY
#else
template<class type_parameter_0_0> using is_array = std::is_array<type_parameter_0_0>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_FUNCTION
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_FUNCTION
#else
template<class type_parameter_0_0> using is_function = std::is_function<type_parameter_0_0>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_FLOATING_POINT
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_FLOATING_POINT
#else
template<class _Tp> using is_floating_point = std::is_floating_point<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_MEMBER_OBJECT_POINTER
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_MEMBER_OBJECT_POINTER
#else
template<class _Tp> using is_member_object_pointer = std::is_member_object_pointer<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_INTEGRAL
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_INTEGRAL
#else
template<class _Tp> using is_integral = std::is_integral<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_VOLATILE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_VOLATILE
#else
template<class _Tp> using add_volatile = std::add_volatile<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_SIGNED
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_SIGNED
#else
template<class _Tp> using is_signed = std::is_signed<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_UNSIGNED
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_UNSIGNED
#else
template<class _Tp> using is_unsigned = std::is_unsigned<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_REFERENCE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_REFERENCE
#else
template<class _Tp> using remove_reference = std::remove_reference<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_REFERENCE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_REFERENCE
#else
template<class type_parameter_0_0> using remove_reference = std::remove_reference<type_parameter_0_0>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_TRUE_TYPE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_TRUE_TYPE
#else
using std::true_type;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_CONDITIONAL
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_CONDITIONAL
#else
template<bool _0, class _Iftrue, class _Iffalse> using conditional = std::conditional<_0, _Iftrue, _Iffalse>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_CONDITIONAL
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_CONDITIONAL
#else
template<bool _0, class type_parameter_0_1, class type_parameter_0_2> using conditional = std::conditional<_0, type_parameter_0_1, type_parameter_0_2>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_POLYMORPHIC
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_POLYMORPHIC
#else
template<class _Tp> using is_polymorphic = std::is_polymorphic<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_ALL_EXTENTS
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_ALL_EXTENTS
#else
template<class _Tp> using remove_all_extents = std::remove_all_extents<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_ALL_EXTENTS
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_ALL_EXTENTS
#else
template<class type_parameter_0_0> using remove_all_extents = std::remove_all_extents<type_parameter_0_0>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_RANK
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_RANK
#else
template<class type_parameter_0_0> using rank = std::rank<type_parameter_0_0>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_NOTHROW_MOVE_CONSTRUCTIBLE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_NOTHROW_MOVE_CONSTRUCTIBLE
#else
template<class _Tp> using is_nothrow_move_constructible = std::is_nothrow_move_constructible<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_FALSE_TYPE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_FALSE_TYPE
#else
using std::false_type;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_SCALAR
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_SCALAR
#else
template<class _Tp> using is_scalar = std::is_scalar<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_UNION
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_UNION
#else
template<class _Tp> using is_union = std::is_union<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_DECLVAL
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_DECLVAL
#else
using std::declval;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_VOID
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_VOID
#else
template<class _Tp> using is_void = std::is_void<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_CV
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_CV
#else
template<class _Tp> using remove_cv = std::remove_cv<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_CV
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_CV
#else
template<class type_parameter_0_0> using remove_cv = std::remove_cv<type_parameter_0_0>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_INTEGRAL_CONSTANT
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_INTEGRAL_CONSTANT
#else
template<class _Tp, _Tp _1> using integral_constant = std::integral_constant<_Tp, _1>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_ARITHMETIC
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_ARITHMETIC
#else
template<class _Tp> using is_arithmetic = std::is_arithmetic<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_HAS_TRIVIAL_DEFAULT_CONSTRUCTOR
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_HAS_TRIVIAL_DEFAULT_CONSTRUCTOR
#else
template<class _Tp> using has_trivial_default_constructor = std::has_trivial_default_constructor<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_FUNDAMENTAL
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_FUNDAMENTAL
#else
template<class _Tp> using is_fundamental = std::is_fundamental<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_ABSTRACT
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_ABSTRACT
#else
template<class _Tp> using is_abstract = std::is_abstract<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_MEMBER_POINTER
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_MEMBER_POINTER
#else
template<class _Tp> using is_member_pointer = std::is_member_pointer<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_MEMBER_POINTER
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_MEMBER_POINTER
#else
template<class type_parameter_0_0> using is_member_pointer = std::is_member_pointer<type_parameter_0_0>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_VOLATILE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_VOLATILE
#else
template<class type_parameter_0_0> using is_volatile = std::is_volatile<type_parameter_0_0>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_DECAY
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_DECAY
#else
template<class _Tp> using decay = std::decay<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_ALIGNMENT_OF
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_ALIGNMENT_OF
#else
template<class _Tp> using alignment_of = std::alignment_of<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_LVALUE_REFERENCE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_LVALUE_REFERENCE
#else
template<class _Tp> using add_lvalue_reference = std::add_lvalue_reference<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_POD
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_POD
#else
template<class _Tp> using is_pod = std::is_pod<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_COMPOUND
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_COMPOUND
#else
template<class _Tp> using is_compound = std::is_compound<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_RVALUE_REFERENCE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_RVALUE_REFERENCE
#else
template<class _Tp> using add_rvalue_reference = std::add_rvalue_reference<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_RVALUE_REFERENCE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_RVALUE_REFERENCE
#else
template<class type_parameter_0_0> using add_rvalue_reference = std::add_rvalue_reference<type_parameter_0_0>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_CONST
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_CONST
#else
template<class _Tp> using remove_const = std::remove_const<_Tp>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_EXTENT
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_EXTENT
#else
template<class type_parameter_0_0, unsigned int _1> using extent = std::extent<type_parameter_0_0, _1>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_REFERENCE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_REFERENCE
#else
template<class _Tp> using is_reference = std::is_reference<_Tp>;
#endif
BOOST_STL11_TYPE_TRAITS_MAP_NAMESPACE_END
#undef BOOST_STL11_TYPE_TRAITS_MAP_NAMESPACE_BEGIN
#undef BOOST_STL11_TYPE_TRAITS_MAP_NAMESPACE_END
