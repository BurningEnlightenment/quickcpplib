/* This is an automatically generated bindings file. Don't modify it! */
#if !defined(BOOST_STL11_FUTURE_MAP_NAMESPACE_BEGIN) || !defined(BOOST_STL11_FUTURE_MAP_NAMESPACE_END)
#error You need to define BOOST_STL11_FUTURE_MAP_NAMESPACE_BEGIN and BOOST_STL11_FUTURE_MAP_NAMESPACE_END to use this header file
#endif
#include <boost/thread.hpp>
BOOST_STL11_FUTURE_MAP_NAMESPACE_BEGIN
extern const char *boost_local_bind_in;
using boost::launch;
using boost::future_status;
using boost::future_errc;
using boost::memory_order;
  using boost::memory_order_relaxed;
  using boost::memory_order_consume;
  using boost::memory_order_acquire;
  using boost::memory_order_release;
  using boost::memory_order_acq_rel;
  using boost::memory_order_seq_cst;
using boost::cv_status;
using boost::async;
template<class R> using packaged_task = boost::packaged_task<R>;
template<class R> using promise = boost::promise<R>;
template<class R> using shared_future = boost::shared_future<R>;
template<class T> using hash = boost::hash<T>;
template<class T, T _1> using integral_constant = boost::integral_constant<T, _1>;
using try_to_lock_t = boost::try_to_lock_t;
using boost::static_pointer_cast;
template<class R1, class R2> using ratio_less_equal = boost::ratio_less_equal<R1, R2>;
using boost::declval;
using boost::tera;
template<class T> using is_array = boost::is_array<T>;
template<class T> using is_member_pointer = boost::is_member_pointer<T>;
template<class T> using is_reference = boost::is_reference<T>;
using boost::atomic_store;
template<class T> using is_lvalue_reference = boost::is_lvalue_reference<T>;
using boost::peta;
template<class From, class To> using is_convertible = boost::is_convertible<From, To>;
using boost::get_deleter;
template<class T> using alignment_of = boost::alignment_of<T>;
using boost::const_pointer_cast;
using boost::swap;
template<class R1, class R2> using ratio_not_equal = boost::ratio_not_equal<R1, R2>;
using boost::dynamic_pointer_cast;
template<class T> using enable_shared_from_this = boost::enable_shared_from_this<T>;
template<class T> using remove_cv = boost::remove_cv<T>;
template<class Base, class Derived> using is_base_of = boost::is_base_of<Base, Derived>;
template<class T> using is_abstract = boost::is_abstract<T>;
template<class Mutex> using lock_guard = boost::lock_guard<Mutex>;
template<class T> using add_rvalue_reference = boost::add_rvalue_reference<T>;
template<class T, class U> using is_same = boost::is_same<T, U>;
template<class T> using is_function = boost::is_function<T>;
template<class T> using is_fundamental = boost::is_fundamental<T>;
using boost::atomic_exchange;
template<class T> using remove_reference = boost::remove_reference<T>;
template<class Cond, class T> using enable_if = boost::enable_if<Cond, T>;
using boost::micro;
using boost::false_type;
template<class T> using remove_const = boost::remove_const<T>;
using boost::centi;
template<class T> using remove_volatile = boost::remove_volatile<T>;
template<class T> using add_pointer = boost::add_pointer<T>;
template<bool _0, class T, class U> using conditional = boost::conditional<_0, T, U>;
template<class T> using is_nothrow_move_constructible = boost::is_nothrow_move_constructible<T>;
template<class T> using is_placeholder = boost::is_placeholder<T>;
using boost::forward;
using boost::kilo;
template<class T> using weak_ptr = boost::weak_ptr<T>;
using boost::atomic_load;
template<class T> using is_member_function_pointer = boost::is_member_function_pointer<T>;
using boost::true_type;
template<class T> using is_scalar = boost::is_scalar<T>;
template<class T> using is_pod = boost::is_pod<T>;
template<class T> using add_const = boost::add_const<T>;
using boost::future_category;
template<class T> using is_enum = boost::is_enum<T>;
template<class T> using has_trivial_copy_constructor = boost::has_trivial_copy_constructor<T>;
using adopt_lock_t = boost::adopt_lock_t;
template<class T> using remove_extent = boost::remove_extent<T>;
template<class T> using is_class = boost::is_class<T>;
using boost::exa;
using boost::milli;
template<class T> using is_unsigned = boost::is_unsigned<T>;
using boost::deca;
template<class T> using is_void = boost::is_void<T>;
using boost::move;
template<class T> using shared_ptr = boost::shared_ptr<T>;
using boost::move_backward;
using boost::pico;
template<class T> using is_union = boost::is_union<T>;
using boost::atomic_load_explicit;
template<class T> using is_const = boost::is_const<T>;
template<class T> using is_nothrow_move_assignable = boost::is_nothrow_move_assignable<T>;
template<class T> using add_volatile = boost::add_volatile<T>;
using defer_lock_t = boost::defer_lock_t;
template<class T> using is_rvalue_reference = boost::is_rvalue_reference<T>;
template<class R1, class R2> using ratio_greater = boost::ratio_greater<R1, R2>;
template<class R1, class R2> using ratio_less = boost::ratio_less<R1, R2>;
using boost::mem_fn;
template<class T> using is_bind_expression = boost::is_bind_expression<T>;
using recursive_timed_mutex = boost::recursive_timed_mutex;
template<class R1, class R2> using ratio_greater_equal = boost::ratio_greater_equal<R1, R2>;
using boost::atto;
using boost::femto;
template<class T> using decay = boost::decay<T>;
using boost::nano;
using boost::deci;
using boost::hecto;
using boost::mega;
using boost::atomic_exchange_explicit;
using boost::giga;
template<class T> using is_floating_point = boost::is_floating_point<T>;
template<class Mutex> using unique_lock = boost::unique_lock<Mutex>;
using mutex = boost::mutex;
using timed_mutex = boost::timed_mutex;
using condition_variable = boost::condition_variable;
template<class F> using result_of = boost::result_of<F>;
using boost::make_move_iterator;
template<boost::intmax_t _0, boost::intmax_t _1> using ratio = boost::ratio<_0, _1>;
using boost::addressof;
template<class T> using reference_wrapper = boost::reference_wrapper<T>;
template<class T> using is_pointer = boost::is_pointer<T>;
template<class T> using is_volatile = boost::is_volatile<T>;
using boost::ref;
using boost::cref;
using boost::next;
using boost::atomic_store_explicit;
using boost::bind;
template<class T> using is_integral = boost::is_integral<T>;
using thread = boost::thread;
template<class R1, class R2> using ratio_equal = boost::ratio_equal<R1, R2>;
template<class Signature> using function = boost::function<Signature>;
template<class T> using is_signed = boost::is_signed<T>;
using boost::call_once;
using boost::atomic_is_lock_free;
using once_flag = boost::once_flag;
using recursive_mutex = boost::recursive_mutex;
using boost::lock;
using boost::try_lock;
template<class It> using move_iterator = boost::move_iterator<It>;
template<std::size_t _0, std::size_t _1> using aligned_storage = boost::aligned_storage<_0, _1>;
using bad_weak_ptr = boost::bad_weak_ptr;
template<class T> using add_cv = boost::add_cv<T>;
using bad_function_call = boost::bad_function_call;
using boost::to_string;
template<class T> using is_arithmetic = boost::is_arithmetic<T>;
template<class... T> using common_type = boost::common_type<T...>;
using future_error = boost::future_error;
BOOST_STL11_FUTURE_MAP_NAMESPACE_END
#undef BOOST_STL11_FUTURE_MAP_NAMESPACE_BEGIN
#undef BOOST_STL11_FUTURE_MAP_NAMESPACE_END
