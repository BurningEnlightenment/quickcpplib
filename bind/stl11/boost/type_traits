/* This is an automatically generated bindings file. Don't modify it! */
#if !defined(BOOST_STL11_TYPE_TRAITS_MAP_NAMESPACE_BEGIN) || !defined(BOOST_STL11_TYPE_TRAITS_MAP_NAMESPACE_END)
#error You need to define BOOST_STL11_TYPE_TRAITS_MAP_NAMESPACE_BEGIN and BOOST_STL11_TYPE_TRAITS_MAP_NAMESPACE_END to use this header file
#endif
#include <boost/type_traits.hpp>
BOOST_STL11_TYPE_TRAITS_MAP_NAMESPACE_BEGIN
extern const char *boost_bindlib_in;
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_RANK
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_RANK
#else
template<class T> using rank = ::boost::rank<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_MAKE_UNSIGNED
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_MAKE_UNSIGNED
#else
template<class T> using make_unsigned = ::boost::make_unsigned<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_UNSIGNED
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_UNSIGNED
#else
template<class T> using is_unsigned = ::boost::is_unsigned<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_UNION
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_UNION
#else
template<class T> using is_union = ::boost::is_union<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_POLYMORPHIC
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_POLYMORPHIC
#else
template<class T> using is_polymorphic = ::boost::is_polymorphic<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_NOTHROW_MOVE_ASSIGNABLE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_NOTHROW_MOVE_ASSIGNABLE
#else
template<class T> using is_nothrow_move_assignable = ::boost::is_nothrow_move_assignable<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_ENABLE_IF
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_ENABLE_IF
#else
template<class Cond, class T> using enable_if = ::boost::enable_if<Cond, T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_FLOATING_POINT
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_FLOATING_POINT
#else
template<class T> using is_floating_point = ::boost::is_floating_point<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_MEMBER_OBJECT_POINTER
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_MEMBER_OBJECT_POINTER
#else
template<class T> using is_member_object_pointer = ::boost::is_member_object_pointer<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_EMPTY
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_EMPTY
#else
template<class T> using is_empty = ::boost::is_empty<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_COMPOUND
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_COMPOUND
#else
template<class T> using is_compound = ::boost::is_compound<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_HAS_VIRTUAL_DESTRUCTOR
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_HAS_VIRTUAL_DESTRUCTOR
#else
template<class T> using has_virtual_destructor = ::boost::has_virtual_destructor<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_CONST
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_CONST
#else
template<class T> using is_const = ::boost::is_const<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_ALIGNED_STORAGE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_ALIGNED_STORAGE
#else
template<std::size_t _0, std::size_t _1> using aligned_storage = ::boost::aligned_storage<_0, _1>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_EXTENT
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_EXTENT
#else
template<class T, std::size_t _1> using extent = ::boost::extent<T, _1>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_ABSTRACT
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_ABSTRACT
#else
template<class T> using is_abstract = ::boost::is_abstract<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_CONST
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_CONST
#else
template<class T> using remove_const = ::boost::remove_const<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_DECAY
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_DECAY
#else
template<class T> using decay = ::boost::decay<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_FUNDAMENTAL
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_FUNDAMENTAL
#else
template<class T> using is_fundamental = ::boost::is_fundamental<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_CONDITIONAL
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_CONDITIONAL
#else
template<bool _0, class T, class U> using conditional = ::boost::conditional<_0, T, U>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_MAKE_SIGNED
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_MAKE_SIGNED
#else
template<class T> using make_signed = ::boost::make_signed<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_POINTER
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_POINTER
#else
template<class T> using is_pointer = ::boost::is_pointer<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_COMMON_TYPE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_COMMON_TYPE
#else
template<class... T> using common_type = ::boost::common_type<T...>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_CONST
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_CONST
#else
template<class T> using add_const = ::boost::add_const<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_DECLVAL
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_DECLVAL
#else
using ::boost::declval;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_FALSE_TYPE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_FALSE_TYPE
#else
using ::boost::false_type;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_POD
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_POD
#else
template<class T> using is_pod = ::boost::is_pod<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_NOTHROW_MOVE_CONSTRUCTIBLE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_NOTHROW_MOVE_CONSTRUCTIBLE
#else
template<class T> using is_nothrow_move_constructible = ::boost::is_nothrow_move_constructible<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_MEMBER_POINTER
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_MEMBER_POINTER
#else
template<class T> using is_member_pointer = ::boost::is_member_pointer<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_INTEGRAL
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_INTEGRAL
#else
template<class T> using is_integral = ::boost::is_integral<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_CV
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_CV
#else
template<class T> using remove_cv = ::boost::remove_cv<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_INTEGRAL_CONSTANT
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_INTEGRAL_CONSTANT
#else
template<class T, T _1> using integral_constant = ::boost::integral_constant<T, _1>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_ENUM
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_ENUM
#else
template<class T> using is_enum = ::boost::is_enum<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_REFERENCE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_REFERENCE
#else
template<class T> using is_reference = ::boost::is_reference<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_FUNCTION
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_FUNCTION
#else
template<class T> using is_function = ::boost::is_function<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_VOID
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_VOID
#else
template<class T> using is_void = ::boost::is_void<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_LVALUE_REFERENCE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_LVALUE_REFERENCE
#else
template<class T> using is_lvalue_reference = ::boost::is_lvalue_reference<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_BASE_OF
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_BASE_OF
#else
template<class Base, class Derived> using is_base_of = ::boost::is_base_of<Base, Derived>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_ARITHMETIC
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_ARITHMETIC
#else
template<class T> using is_arithmetic = ::boost::is_arithmetic<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_POINTER
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_POINTER
#else
template<class T> using add_pointer = ::boost::add_pointer<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_RVALUE_REFERENCE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_RVALUE_REFERENCE
#else
template<class T> using is_rvalue_reference = ::boost::is_rvalue_reference<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_CV
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_CV
#else
template<class T> using add_cv = ::boost::add_cv<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_LVALUE_REFERENCE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_LVALUE_REFERENCE
#else
template<class T> using add_lvalue_reference = ::boost::add_lvalue_reference<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_SCALAR
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_SCALAR
#else
template<class T> using is_scalar = ::boost::is_scalar<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_TRUE_TYPE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_TRUE_TYPE
#else
using ::boost::true_type;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_REFERENCE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_REFERENCE
#else
template<class T> using remove_reference = ::boost::remove_reference<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_VOLATILE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_VOLATILE
#else
template<class T> using add_volatile = ::boost::add_volatile<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_EXTENT
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_EXTENT
#else
template<class T> using remove_extent = ::boost::remove_extent<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_CLASS
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_CLASS
#else
template<class T> using is_class = ::boost::is_class<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_HAS_TRIVIAL_DEFAULT_CONSTRUCTOR
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_HAS_TRIVIAL_DEFAULT_CONSTRUCTOR
#else
template<class T> using has_trivial_default_constructor = ::boost::has_trivial_default_constructor<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_ALL_EXTENTS
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_ALL_EXTENTS
#else
template<class T> using remove_all_extents = ::boost::remove_all_extents<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_HAS_TRIVIAL_COPY_CONSTRUCTOR
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_HAS_TRIVIAL_COPY_CONSTRUCTOR
#else
template<class T> using has_trivial_copy_constructor = ::boost::has_trivial_copy_constructor<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_MEMBER_FUNCTION_POINTER
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_MEMBER_FUNCTION_POINTER
#else
template<class T> using is_member_function_pointer = ::boost::is_member_function_pointer<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_VOLATILE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_VOLATILE
#else
template<class T> using is_volatile = ::boost::is_volatile<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_ARRAY
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_ARRAY
#else
template<class T> using is_array = ::boost::is_array<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_POINTER
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_POINTER
#else
template<class T> using remove_pointer = ::boost::remove_pointer<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_SIGNED
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_SIGNED
#else
template<class T> using is_signed = ::boost::is_signed<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_CONVERTIBLE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_CONVERTIBLE
#else
template<class From, class To> using is_convertible = ::boost::is_convertible<From, To>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_ALIGNMENT_OF
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_ALIGNMENT_OF
#else
template<class T> using alignment_of = ::boost::alignment_of<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_SAME
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_SAME
#else
template<class T, class U> using is_same = ::boost::is_same<T, U>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_RVALUE_REFERENCE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_ADD_RVALUE_REFERENCE
#else
template<class T> using add_rvalue_reference = ::boost::add_rvalue_reference<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_OBJECT
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_IS_OBJECT
#else
template<class T> using is_object = ::boost::is_object<T>;
#endif
#ifdef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_VOLATILE
#undef BOOST_STL11_TYPE_TRAITS_MAP_NO_REMOVE_VOLATILE
#else
template<class T> using remove_volatile = ::boost::remove_volatile<T>;
#endif
BOOST_STL11_TYPE_TRAITS_MAP_NAMESPACE_END
#undef BOOST_STL11_TYPE_TRAITS_MAP_NAMESPACE_BEGIN
#undef BOOST_STL11_TYPE_TRAITS_MAP_NAMESPACE_END
