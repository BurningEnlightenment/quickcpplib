/* This is an automatically generated bindings file. Don't modify it! */
#if !defined(BOOST_STL1z_NETWORKING_MAP_NAMESPACE_BEGIN) || !defined(BOOST_STL1z_NETWORKING_MAP_NAMESPACE_END)
#error You need to define BOOST_STL1z_NETWORKING_MAP_NAMESPACE_BEGIN and BOOST_STL1z_NETWORKING_MAP_NAMESPACE_END to use this header file
#endif
#include <asio.hpp>
BOOST_STL1z_NETWORKING_MAP_NAMESPACE_BEGIN
extern const char *boost_local_bind_in;
namespace ip { using asio::ip::v4_mapped_t;  using asio::ip::v4_mapped;
 }
namespace error { using asio::error::misc_errors;  using asio::error::already_open;
  using asio::error::eof;
  using asio::error::not_found;
  using asio::error::fd_set_failure;
 }
namespace error { using asio::error::addrinfo_errors;  using asio::error::service_not_found;
  using asio::error::socket_type_not_supported;
 }
namespace error { using asio::error::netdb_errors;  using asio::error::host_not_found;
  using asio::error::host_not_found_try_again;
  using asio::error::no_data;
  using asio::error::no_recovery;
 }
namespace error { using asio::error::basic_errors;  using asio::error::access_denied;
  using asio::error::address_family_not_supported;
  using asio::error::address_in_use;
  using asio::error::already_connected;
  using asio::error::already_started;
  using asio::error::broken_pipe;
  using asio::error::connection_aborted;
  using asio::error::connection_refused;
  using asio::error::connection_reset;
  using asio::error::bad_descriptor;
  using asio::error::fault;
  using asio::error::host_unreachable;
  using asio::error::in_progress;
  using asio::error::interrupted;
  using asio::error::invalid_argument;
  using asio::error::message_size;
  using asio::error::name_too_long;
  using asio::error::network_down;
  using asio::error::network_reset;
  using asio::error::network_unreachable;
  using asio::error::no_descriptors;
  using asio::error::no_buffer_space;
  using asio::error::no_memory;
  using asio::error::no_permission;
  using asio::error::no_protocol_option;
  using asio::error::not_connected;
  using asio::error::not_socket;
  using asio::error::operation_aborted;
  using asio::error::operation_not_supported;
  using asio::error::shut_down;
  using asio::error::timed_out;
  using asio::error::try_again;
  using asio::error::would_block;
 }
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_WRITE_AT
#undef BOOST_STL1z_NETWORKING_MAP_NO_WRITE_AT
#else
using asio::write_at;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_EXECUTOR_ARG_T
#undef BOOST_STL1z_NETWORKING_MAP_NO_EXECUTOR_ARG_T
#else
using executor_arg_t = asio::executor_arg_t;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_THREAD
#undef BOOST_STL1z_NETWORKING_MAP_NO_THREAD
#else
using thread = asio::thread;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_STREAMBUF
#undef BOOST_STL1z_NETWORKING_MAP_NO_STREAMBUF
#else
using asio::streambuf;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_SIGNAL_SET
#undef BOOST_STL1z_NETWORKING_MAP_NO_SIGNAL_SET
#else
using asio::signal_set;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_SERIAL_PORT
#undef BOOST_STL1z_NETWORKING_MAP_NO_SERIAL_PORT
#else
using asio::serial_port;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ASYNC_READ_AT
#undef BOOST_STL1z_NETWORKING_MAP_NO_ASYNC_READ_AT
#else
using asio::async_read_at;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_READ
#undef BOOST_STL1z_NETWORKING_MAP_NO_READ
#else
using asio::read;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_DESCRIPTOR
#undef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_DESCRIPTOR
#else
namespace posix { template<class DescriptorService> using basic_descriptor = asio::posix::basic_descriptor<DescriptorService>; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_DATAGRAM_PROTOCOL
#undef BOOST_STL1z_NETWORKING_MAP_NO_DATAGRAM_PROTOCOL
#else
namespace local { using datagram_protocol = asio::local::datagram_protocol; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_STREAM_DESCRIPTOR
#undef BOOST_STL1z_NETWORKING_MAP_NO_STREAM_DESCRIPTOR
#else
namespace posix { using asio::posix::stream_descriptor; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_ENDPOINT
#undef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_ENDPOINT
#else
namespace local { template<class Protocol> using basic_endpoint = asio::local::basic_endpoint<Protocol>; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_READ_UNTIL
#undef BOOST_STL1z_NETWORKING_MAP_NO_READ_UNTIL
#else
using asio::read_until;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_IS_READ_BUFFERED
#undef BOOST_STL1z_NETWORKING_MAP_NO_IS_READ_BUFFERED
#else
template<class Stream> using is_read_buffered = asio::is_read_buffered<Stream>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_V6_ONLY
#undef BOOST_STL1z_NETWORKING_MAP_NO_V6_ONLY
#else
namespace ip { using asio::ip::v6_only; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_HOPS
#undef BOOST_STL1z_NETWORKING_MAP_NO_HOPS
#else
namespace ip { namespace unicast { using asio::ip::unicast::hops; } }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_UDP
#undef BOOST_STL1z_NETWORKING_MAP_NO_UDP
#else
namespace ip { using udp = asio::ip::udp; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_TCP
#undef BOOST_STL1z_NETWORKING_MAP_NO_TCP
#else
namespace ip { using tcp = asio::ip::tcp; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ENABLE_LOOPBACK
#undef BOOST_STL1z_NETWORKING_MAP_NO_ENABLE_LOOPBACK
#else
namespace ip { namespace multicast { using asio::ip::multicast::enable_loopback; } }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_HOPS
#undef BOOST_STL1z_NETWORKING_MAP_NO_HOPS
#else
namespace ip { namespace multicast { using asio::ip::multicast::hops; } }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_JOIN_GROUP
#undef BOOST_STL1z_NETWORKING_MAP_NO_JOIN_GROUP
#else
namespace ip { namespace multicast { using asio::ip::multicast::join_group; } }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_NETWORK_INTERFACE
#undef BOOST_STL1z_NETWORKING_MAP_NO_NETWORK_INTERFACE
#else
namespace ip { namespace detail { namespace socket_option { template<int _0, int _1, int _2, int _3> using network_interface = asio::ip::detail::socket_option::network_interface<_0, _1, _2, _3>; } } }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_MULTICAST_REQUEST
#undef BOOST_STL1z_NETWORKING_MAP_NO_MULTICAST_REQUEST
#else
namespace ip { namespace detail { namespace socket_option { template<int _0, int _1, int _2, int _3> using multicast_request = asio::ip::detail::socket_option::multicast_request<_0, _1, _2, _3>; } } }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_MULTICAST_HOPS
#undef BOOST_STL1z_NETWORKING_MAP_NO_MULTICAST_HOPS
#else
namespace ip { namespace detail { namespace socket_option { template<int _0, int _1, int _2, int _3> using multicast_hops = asio::ip::detail::socket_option::multicast_hops<_0, _1, _2, _3>; } } }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_MULTICAST_ENABLE_LOOPBACK
#undef BOOST_STL1z_NETWORKING_MAP_NO_MULTICAST_ENABLE_LOOPBACK
#else
namespace ip { namespace detail { namespace socket_option { template<int _0, int _1, int _2, int _3> using multicast_enable_loopback = asio::ip::detail::socket_option::multicast_enable_loopback<_0, _1, _2, _3>; } } }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ICMP
#undef BOOST_STL1z_NETWORKING_MAP_NO_ICMP
#else
namespace ip { using icmp = asio::ip::icmp; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_RESOLVER
#undef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_RESOLVER
#else
namespace ip { template<class InternetProtocol, class ResolverService> using basic_resolver = asio::ip::basic_resolver<InternetProtocol, ResolverService>; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_RESOLVER_QUERY_BASE
#undef BOOST_STL1z_NETWORKING_MAP_NO_RESOLVER_QUERY_BASE
#else
namespace ip { using resolver_query_base = asio::ip::resolver_query_base; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_RESOLVER_ENTRY
#undef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_RESOLVER_ENTRY
#else
namespace ip { template<class InternetProtocol> using basic_resolver_entry = asio::ip::basic_resolver_entry<InternetProtocol>; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_ENDPOINT
#undef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_ENDPOINT
#else
namespace ip { template<class InternetProtocol> using basic_endpoint = asio::ip::basic_endpoint<InternetProtocol>; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ENDPOINT
#undef BOOST_STL1z_NETWORKING_MAP_NO_ENDPOINT
#else
namespace ip { namespace detail { using endpoint = asio::ip::detail::endpoint; } }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ADDRESS
#undef BOOST_STL1z_NETWORKING_MAP_NO_ADDRESS
#else
namespace ip { using address = asio::ip::address; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BAD_ADDRESS_CAST
#undef BOOST_STL1z_NETWORKING_MAP_NO_BAD_ADDRESS_CAST
#else
namespace ip { using bad_address_cast = asio::ip::bad_address_cast; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_MAKE_ADDRESS_V6
#undef BOOST_STL1z_NETWORKING_MAP_NO_MAKE_ADDRESS_V6
#else
namespace ip { using asio::ip::make_address_v6; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ADDRESS_CAST
#undef BOOST_STL1z_NETWORKING_MAP_NO_ADDRESS_CAST
#else
namespace ip { using asio::ip::address_cast; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ADDRESS_V6
#undef BOOST_STL1z_NETWORKING_MAP_NO_ADDRESS_V6
#else
namespace ip { using address_v6 = asio::ip::address_v6; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_HOST_NAME
#undef BOOST_STL1z_NETWORKING_MAP_NO_HOST_NAME
#else
namespace ip { using asio::ip::host_name; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_IS_MUTABLE_BUFFER_SEQUENCE
#undef BOOST_STL1z_NETWORKING_MAP_NO_IS_MUTABLE_BUFFER_SEQUENCE
#else
template<class T> using is_mutable_buffer_sequence = asio::is_mutable_buffer_sequence<T>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_LEAVE_GROUP
#undef BOOST_STL1z_NETWORKING_MAP_NO_LEAVE_GROUP
#else
namespace ip { namespace multicast { using asio::ip::multicast::leave_group; } }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ADDRESS_V4
#undef BOOST_STL1z_NETWORKING_MAP_NO_ADDRESS_V4
#else
namespace ip { using address_v4 = asio::ip::address_v4; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_RESOLVER_ITERATOR
#undef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_RESOLVER_ITERATOR
#else
namespace ip { template<class InternetProtocol> using basic_resolver_iterator = asio::ip::basic_resolver_iterator<InternetProtocol>; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_SOCKET_BASE
#undef BOOST_STL1z_NETWORKING_MAP_NO_SOCKET_BASE
#else
using socket_base = asio::socket_base;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BUFFERED_WRITE_STREAM
#undef BOOST_STL1z_NETWORKING_MAP_NO_BUFFERED_WRITE_STREAM
#else
template<class Stream> using buffered_write_stream = asio::buffered_write_stream<Stream>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_WRAP
#undef BOOST_STL1z_NETWORKING_MAP_NO_WRAP
#else
using asio::wrap;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_MAKE_WORK
#undef BOOST_STL1z_NETWORKING_MAP_NO_MAKE_WORK
#else
using asio::make_work;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_READ_AT
#undef BOOST_STL1z_NETWORKING_MAP_NO_READ_AT
#else
using asio::read_at;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ASYNC_RESULT
#undef BOOST_STL1z_NETWORKING_MAP_NO_ASYNC_RESULT
#else
template<class Handler> using async_result = asio::async_result<Handler>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_STREAM_SOCKET
#undef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_STREAM_SOCKET
#else
template<class Protocol, class StreamSocketService> using basic_stream_socket = asio::basic_stream_socket<Protocol, StreamSocketService>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ASIO_HANDLER_IS_CONTINUATION
#undef BOOST_STL1z_NETWORKING_MAP_NO_ASIO_HANDLER_IS_CONTINUATION
#else
using asio::asio_handler_is_continuation;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_NULL_BUFFERS
#undef BOOST_STL1z_NETWORKING_MAP_NO_NULL_BUFFERS
#else
using null_buffers = asio::null_buffers;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_EXECUTOR_WORK
#undef BOOST_STL1z_NETWORKING_MAP_NO_EXECUTOR_WORK
#else
template<class Executor> using executor_work = asio::executor_work<Executor>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_MUTABLE_BUFFERS_1
#undef BOOST_STL1z_NETWORKING_MAP_NO_MUTABLE_BUFFERS_1
#else
using mutable_buffers_1 = asio::mutable_buffers_1;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_SOCKET_STREAMBUF
#undef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_SOCKET_STREAMBUF
#else
template<class Protocol, class StreamSocketService, class Time, class TimeTraits, class TimerService> using basic_socket_streambuf = asio::basic_socket_streambuf<Protocol, StreamSocketService, Time, TimeTraits, TimerService>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_MAKE_ADDRESS
#undef BOOST_STL1z_NETWORKING_MAP_NO_MAKE_ADDRESS
#else
namespace ip { using asio::ip::make_address; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_CONST_BUFFERS_1
#undef BOOST_STL1z_NETWORKING_MAP_NO_CONST_BUFFERS_1
#else
using const_buffers_1 = asio::const_buffers_1;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_IS_WRITE_BUFFERED
#undef BOOST_STL1z_NETWORKING_MAP_NO_IS_WRITE_BUFFERED
#else
template<class Stream> using is_write_buffered = asio::is_write_buffered<Stream>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ASIO_HANDLER_INVOKE
#undef BOOST_STL1z_NETWORKING_MAP_NO_ASIO_HANDLER_INVOKE
#else
using asio::asio_handler_invoke;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BAD_EXECUTOR
#undef BOOST_STL1z_NETWORKING_MAP_NO_BAD_EXECUTOR
#else
using bad_executor = asio::bad_executor;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_SERIAL_PORT
#undef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_SERIAL_PORT
#else
template<class SerialPortService> using basic_serial_port = asio::basic_serial_port<SerialPortService>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ENDPOINT
#undef BOOST_STL1z_NETWORKING_MAP_NO_ENDPOINT
#else
namespace generic { namespace detail { using endpoint = asio::generic::detail::endpoint; } }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_SYSTEM_EXECUTOR
#undef BOOST_STL1z_NETWORKING_MAP_NO_SYSTEM_EXECUTOR
#else
using system_executor = asio::system_executor;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BUFFER
#undef BOOST_STL1z_NETWORKING_MAP_NO_BUFFER
#else
using asio::buffer;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_STREAM_DESCRIPTOR
#undef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_STREAM_DESCRIPTOR
#else
namespace posix { template<class StreamDescriptorService> using basic_stream_descriptor = asio::posix::basic_stream_descriptor<StreamDescriptorService>; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ASIO_HANDLER_DEALLOCATE
#undef BOOST_STL1z_NETWORKING_MAP_NO_ASIO_HANDLER_DEALLOCATE
#else
using asio::asio_handler_deallocate;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_GET_ASSOCIATED_EXECUTOR
#undef BOOST_STL1z_NETWORKING_MAP_NO_GET_ASSOCIATED_EXECUTOR
#else
using asio::get_associated_executor;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_MISC_CATEGORY
#undef BOOST_STL1z_NETWORKING_MAP_NO_MISC_CATEGORY
#else
namespace error { namespace detail { using misc_category = asio::error::detail::misc_category; } }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_USE_SERVICE
#undef BOOST_STL1z_NETWORKING_MAP_NO_USE_SERVICE
#else
using asio::use_service;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_IO_OBJECT
#undef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_IO_OBJECT
#else
template<class IoObjectService, bool _1> using basic_io_object = asio::basic_io_object<IoObjectService, _1>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ASYNC_COMPLETION
#undef BOOST_STL1z_NETWORKING_MAP_NO_ASYNC_COMPLETION
#else
template<class Handler, class Signature> using async_completion = asio::async_completion<Handler, Signature>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_INVALID_SERVICE_OWNER
#undef BOOST_STL1z_NETWORKING_MAP_NO_INVALID_SERVICE_OWNER
#else
using invalid_service_owner = asio::invalid_service_owner;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_OUTBOUND_INTERFACE
#undef BOOST_STL1z_NETWORKING_MAP_NO_OUTBOUND_INTERFACE
#else
namespace ip { namespace multicast { using asio::ip::multicast::outbound_interface; } }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_EXECUTION_CONTEXT
#undef BOOST_STL1z_NETWORKING_MAP_NO_EXECUTION_CONTEXT
#else
using execution_context = asio::execution_context;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_POST
#undef BOOST_STL1z_NETWORKING_MAP_NO_POST
#else
using asio::post;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BUFFERS_END
#undef BOOST_STL1z_NETWORKING_MAP_NO_BUFFERS_END
#else
using asio::buffers_end;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_EXECUTOR_WRAPPER
#undef BOOST_STL1z_NETWORKING_MAP_NO_EXECUTOR_WRAPPER
#else
template<class T, class Executor> using executor_wrapper = asio::executor_wrapper<T, Executor>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ASYNC_READ
#undef BOOST_STL1z_NETWORKING_MAP_NO_ASYNC_READ
#else
using asio::async_read;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_RESOLVER_SERVICE
#undef BOOST_STL1z_NETWORKING_MAP_NO_RESOLVER_SERVICE
#else
namespace ip { template<class InternetProtocol> using resolver_service = asio::ip::resolver_service<InternetProtocol>; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_CONST_BUFFER
#undef BOOST_STL1z_NETWORKING_MAP_NO_CONST_BUFFER
#else
using const_buffer = asio::const_buffer;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_IO_SERVICE
#undef BOOST_STL1z_NETWORKING_MAP_NO_IO_SERVICE
#else
using io_service = asio::io_service;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_STRAND
#undef BOOST_STL1z_NETWORKING_MAP_NO_STRAND
#else
template<class Executor> using strand = asio::strand<Executor>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BUFFERED_READ_STREAM
#undef BOOST_STL1z_NETWORKING_MAP_NO_BUFFERED_READ_STREAM
#else
template<class Stream> using buffered_read_stream = asio::buffered_read_stream<Stream>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_IS_MATCH_CONDITION
#undef BOOST_STL1z_NETWORKING_MAP_NO_IS_MATCH_CONDITION
#else
template<class T> using is_match_condition = asio::is_match_condition<T>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_NETDB_CATEGORY
#undef BOOST_STL1z_NETWORKING_MAP_NO_NETDB_CATEGORY
#else
namespace error { namespace detail { using netdb_category = asio::error::detail::netdb_category; } }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_TRANSFER_EXACTLY
#undef BOOST_STL1z_NETWORKING_MAP_NO_TRANSFER_EXACTLY
#else
using asio::transfer_exactly;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_CONNECT_PAIR
#undef BOOST_STL1z_NETWORKING_MAP_NO_CONNECT_PAIR
#else
namespace local { using asio::local::connect_pair; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_EXECUTOR
#undef BOOST_STL1z_NETWORKING_MAP_NO_EXECUTOR
#else
using executor = asio::executor;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_RAW_SOCKET
#undef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_RAW_SOCKET
#else
template<class Protocol, class RawSocketService> using basic_raw_socket = asio::basic_raw_socket<Protocol, RawSocketService>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_WAITABLE_TIMER_SERVICE
#undef BOOST_STL1z_NETWORKING_MAP_NO_WAITABLE_TIMER_SERVICE
#else
template<class Clock, class WaitTraits> using waitable_timer_service = asio::waitable_timer_service<Clock, WaitTraits>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_IS_EXECUTOR
#undef BOOST_STL1z_NETWORKING_MAP_NO_IS_EXECUTOR
#else
template<class T> using is_executor = asio::is_executor<T>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ERROR_CATEGORY
#undef BOOST_STL1z_NETWORKING_MAP_NO_ERROR_CATEGORY
#else
using error_category = asio::error_category;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ASYNC_READ_UNTIL
#undef BOOST_STL1z_NETWORKING_MAP_NO_ASYNC_READ_UNTIL
#else
using asio::async_read_until;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_RAW_SOCKET_SERVICE
#undef BOOST_STL1z_NETWORKING_MAP_NO_RAW_SOCKET_SERVICE
#else
template<class Protocol> using raw_socket_service = asio::raw_socket_service<Protocol>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_SOCKET
#undef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_SOCKET
#else
template<class Protocol, class SocketService> using basic_socket = asio::basic_socket<Protocol, SocketService>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_HANDLER_TYPE
#undef BOOST_STL1z_NETWORKING_MAP_NO_HANDLER_TYPE
#else
template<class CompletionToken, class Signature, class type_parameter_0_2> using handler_type = asio::handler_type<CompletionToken, Signature, type_parameter_0_2>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_USES_EXECUTOR
#undef BOOST_STL1z_NETWORKING_MAP_NO_USES_EXECUTOR
#else
template<class T, class Executor> using uses_executor = asio::uses_executor<T, Executor>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_DATAGRAM_SOCKET
#undef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_DATAGRAM_SOCKET
#else
template<class Protocol, class DatagramSocketService> using basic_datagram_socket = asio::basic_datagram_socket<Protocol, DatagramSocketService>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_SYSTEM_CATEGORY
#undef BOOST_STL1z_NETWORKING_MAP_NO_SYSTEM_CATEGORY
#else
using asio::system_category;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ASIO_HANDLER_ALLOCATE
#undef BOOST_STL1z_NETWORKING_MAP_NO_ASIO_HANDLER_ALLOCATE
#else
using asio::asio_handler_allocate;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_GET_ASSOCIATED_ALLOCATOR
#undef BOOST_STL1z_NETWORKING_MAP_NO_GET_ASSOCIATED_ALLOCATOR
#else
using asio::get_associated_allocator;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_STREAM_DESCRIPTOR_SERVICE
#undef BOOST_STL1z_NETWORKING_MAP_NO_STREAM_DESCRIPTOR_SERVICE
#else
namespace posix { using stream_descriptor_service = asio::posix::stream_descriptor_service; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_RAW_PROTOCOL
#undef BOOST_STL1z_NETWORKING_MAP_NO_RAW_PROTOCOL
#else
namespace generic { using raw_protocol = asio::generic::raw_protocol; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_GET_MISC_CATEGORY
#undef BOOST_STL1z_NETWORKING_MAP_NO_GET_MISC_CATEGORY
#else
namespace error { using asio::error::get_misc_category; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_SERVICE_ALREADY_EXISTS
#undef BOOST_STL1z_NETWORKING_MAP_NO_SERVICE_ALREADY_EXISTS
#else
using service_already_exists = asio::service_already_exists;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_GET_SYSTEM_CATEGORY
#undef BOOST_STL1z_NETWORKING_MAP_NO_GET_SYSTEM_CATEGORY
#else
namespace error { using asio::error::get_system_category; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_GET_ADDRINFO_CATEGORY
#undef BOOST_STL1z_NETWORKING_MAP_NO_GET_ADDRINFO_CATEGORY
#else
namespace error { using asio::error::get_addrinfo_category; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ASSOCIATED_EXECUTOR
#undef BOOST_STL1z_NETWORKING_MAP_NO_ASSOCIATED_EXECUTOR
#else
template<class T, class Executor> using associated_executor = asio::associated_executor<T, Executor>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ENABLE_IF
#undef BOOST_STL1z_NETWORKING_MAP_NO_ENABLE_IF
#else
template<bool _0, class Type> using enable_if = asio::enable_if<_0, Type>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_UNICAST_HOPS
#undef BOOST_STL1z_NETWORKING_MAP_NO_UNICAST_HOPS
#else
namespace ip { namespace detail { namespace socket_option { template<int _0, int _1, int _2, int _3> using unicast_hops = asio::ip::detail::socket_option::unicast_hops<_0, _1, _2, _3>; } } }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_SYSTEM_ERROR
#undef BOOST_STL1z_NETWORKING_MAP_NO_SYSTEM_ERROR
#else
using system_error = asio::system_error;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_MAKE_ERROR_CODE
#undef BOOST_STL1z_NETWORKING_MAP_NO_MAKE_ERROR_CODE
#else
namespace error { using asio::error::make_error_code; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ASYNC_WRITE_AT
#undef BOOST_STL1z_NETWORKING_MAP_NO_ASYNC_WRITE_AT
#else
using asio::async_write_at;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_RESOLVER_QUERY
#undef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_RESOLVER_QUERY
#else
namespace ip { template<class InternetProtocol> using basic_resolver_query = asio::ip::basic_resolver_query<InternetProtocol>; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ASSOCIATED_ALLOCATOR
#undef BOOST_STL1z_NETWORKING_MAP_NO_ASSOCIATED_ALLOCATOR
#else
template<class T, class Allocator> using associated_allocator = asio::associated_allocator<T, Allocator>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_HAS_SERVICE
#undef BOOST_STL1z_NETWORKING_MAP_NO_HAS_SERVICE
#else
using asio::has_service;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_CONNECT
#undef BOOST_STL1z_NETWORKING_MAP_NO_CONNECT
#else
using asio::connect;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BUFFER_SIZE
#undef BOOST_STL1z_NETWORKING_MAP_NO_BUFFER_SIZE
#else
using asio::buffer_size;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ENDPOINT
#undef BOOST_STL1z_NETWORKING_MAP_NO_ENDPOINT
#else
namespace local { namespace detail { using endpoint = asio::local::detail::endpoint; } }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BUFFERED_STREAM
#undef BOOST_STL1z_NETWORKING_MAP_NO_BUFFERED_STREAM
#else
template<class Stream> using buffered_stream = asio::buffered_stream<Stream>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_STREAM_PROTOCOL
#undef BOOST_STL1z_NETWORKING_MAP_NO_STREAM_PROTOCOL
#else
namespace local { using stream_protocol = asio::local::stream_protocol; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_GET_NETDB_CATEGORY
#undef BOOST_STL1z_NETWORKING_MAP_NO_GET_NETDB_CATEGORY
#else
namespace error { using asio::error::get_netdb_category; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_SOCKET_ACCEPTOR
#undef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_SOCKET_ACCEPTOR
#else
template<class Protocol, class SocketAcceptorService> using basic_socket_acceptor = asio::basic_socket_acceptor<Protocol, SocketAcceptorService>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ERROR_CODE
#undef BOOST_STL1z_NETWORKING_MAP_NO_ERROR_CODE
#else
using error_code = asio::error_code;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BUFFER_CAST
#undef BOOST_STL1z_NETWORKING_MAP_NO_BUFFER_CAST
#else
using asio::buffer_cast;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BUFFER_COPY
#undef BOOST_STL1z_NETWORKING_MAP_NO_BUFFER_COPY
#else
using asio::buffer_copy;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_SEQ_PACKET_SOCKET_SERVICE
#undef BOOST_STL1z_NETWORKING_MAP_NO_SEQ_PACKET_SOCKET_SERVICE
#else
template<class Protocol> using seq_packet_socket_service = asio::seq_packet_socket_service<Protocol>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_THREAD_POOL
#undef BOOST_STL1z_NETWORKING_MAP_NO_THREAD_POOL
#else
using thread_pool = asio::thread_pool;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_SEQ_PACKET_SOCKET
#undef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_SEQ_PACKET_SOCKET
#else
template<class Protocol, class SeqPacketSocketService> using basic_seq_packet_socket = asio::basic_seq_packet_socket<Protocol, SeqPacketSocketService>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_SERIAL_PORT_BASE
#undef BOOST_STL1z_NETWORKING_MAP_NO_SERIAL_PORT_BASE
#else
using serial_port_base = asio::serial_port_base;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_STREAMBUF
#undef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_STREAMBUF
#else
template<class Allocator> using basic_streambuf = asio::basic_streambuf<Allocator>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_COROUTINE
#undef BOOST_STL1z_NETWORKING_MAP_NO_COROUTINE
#else
using coroutine = asio::coroutine;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_SERIAL_PORT_SERVICE
#undef BOOST_STL1z_NETWORKING_MAP_NO_SERIAL_PORT_SERVICE
#else
using serial_port_service = asio::serial_port_service;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_SOCKET_ACCEPTOR_SERVICE
#undef BOOST_STL1z_NETWORKING_MAP_NO_SOCKET_ACCEPTOR_SERVICE
#else
template<class Protocol> using socket_acceptor_service = asio::socket_acceptor_service<Protocol>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_MAKE_ADDRESS_V4
#undef BOOST_STL1z_NETWORKING_MAP_NO_MAKE_ADDRESS_V4
#else
namespace ip { using asio::ip::make_address_v4; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_TRANSFER_AT_LEAST
#undef BOOST_STL1z_NETWORKING_MAP_NO_TRANSFER_AT_LEAST
#else
using asio::transfer_at_least;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_WRITE
#undef BOOST_STL1z_NETWORKING_MAP_NO_WRITE
#else
using asio::write;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_SIGNAL_SET
#undef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_SIGNAL_SET
#else
template<class SignalSetService> using basic_signal_set = asio::basic_signal_set<SignalSetService>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_SIGNAL_SET_SERVICE
#undef BOOST_STL1z_NETWORKING_MAP_NO_SIGNAL_SET_SERVICE
#else
using signal_set_service = asio::signal_set_service;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_STREAM_SOCKET_SERVICE
#undef BOOST_STL1z_NETWORKING_MAP_NO_STREAM_SOCKET_SERVICE
#else
template<class Protocol> using stream_socket_service = asio::stream_socket_service<Protocol>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_SOCKET_IOSTREAM
#undef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_SOCKET_IOSTREAM
#else
template<class Protocol, class StreamSocketService, class Time, class TimeTraits, class TimerService> using basic_socket_iostream = asio::basic_socket_iostream<Protocol, StreamSocketService, Time, TimeTraits, TimerService>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_DESCRIPTOR_BASE
#undef BOOST_STL1z_NETWORKING_MAP_NO_DESCRIPTOR_BASE
#else
namespace posix { using descriptor_base = asio::posix::descriptor_base; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_READ_SIZE_HELPER
#undef BOOST_STL1z_NETWORKING_MAP_NO_READ_SIZE_HELPER
#else
using asio::read_size_helper;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_WAIT_TRAITS
#undef BOOST_STL1z_NETWORKING_MAP_NO_WAIT_TRAITS
#else
template<class Clock> using wait_traits = asio::wait_traits<Clock>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ADD_SERVICE
#undef BOOST_STL1z_NETWORKING_MAP_NO_ADD_SERVICE
#else
using asio::add_service;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_MUTABLE_BUFFER
#undef BOOST_STL1z_NETWORKING_MAP_NO_MUTABLE_BUFFER
#else
using mutable_buffer = asio::mutable_buffer;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_WAITABLE_TIMER
#undef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_WAITABLE_TIMER
#else
template<class Clock, class WaitTraits, class WaitableTimerService> using basic_waitable_timer = asio::basic_waitable_timer<Clock, WaitTraits, WaitableTimerService>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_DATAGRAM_PROTOCOL
#undef BOOST_STL1z_NETWORKING_MAP_NO_DATAGRAM_PROTOCOL
#else
namespace generic { using datagram_protocol = asio::generic::datagram_protocol; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_IS_CONST_BUFFER_SEQUENCE
#undef BOOST_STL1z_NETWORKING_MAP_NO_IS_CONST_BUFFER_SEQUENCE
#else
template<class T> using is_const_buffer_sequence = asio::is_const_buffer_sequence<T>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_TRANSFER_ALL
#undef BOOST_STL1z_NETWORKING_MAP_NO_TRANSFER_ALL
#else
using asio::transfer_all;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_SEQ_PACKET_PROTOCOL
#undef BOOST_STL1z_NETWORKING_MAP_NO_SEQ_PACKET_PROTOCOL
#else
namespace generic { using seq_packet_protocol = asio::generic::seq_packet_protocol; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ASYNC_WRITE
#undef BOOST_STL1z_NETWORKING_MAP_NO_ASYNC_WRITE
#else
using asio::async_write;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ADDRINFO_CATEGORY
#undef BOOST_STL1z_NETWORKING_MAP_NO_ADDRINFO_CATEGORY
#else
namespace error { namespace detail { using addrinfo_category = asio::error::detail::addrinfo_category; } }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BUFFERS_ITERATOR
#undef BOOST_STL1z_NETWORKING_MAP_NO_BUFFERS_ITERATOR
#else
template<class BufferSequence, class ByteType> using buffers_iterator = asio::buffers_iterator<BufferSequence, ByteType>;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BUFFERS_BEGIN
#undef BOOST_STL1z_NETWORKING_MAP_NO_BUFFERS_BEGIN
#else
using asio::buffers_begin;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_ASYNC_CONNECT
#undef BOOST_STL1z_NETWORKING_MAP_NO_ASYNC_CONNECT
#else
using asio::async_connect;
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_ENDPOINT
#undef BOOST_STL1z_NETWORKING_MAP_NO_BASIC_ENDPOINT
#else
namespace generic { template<class Protocol> using basic_endpoint = asio::generic::basic_endpoint<Protocol>; }
#endif
#ifdef BOOST_STL1z_NETWORKING_MAP_NO_STREAM_PROTOCOL
#undef BOOST_STL1z_NETWORKING_MAP_NO_STREAM_PROTOCOL
#else
namespace generic { using stream_protocol = asio::generic::stream_protocol; }
#endif
BOOST_STL1z_NETWORKING_MAP_NAMESPACE_END
#undef BOOST_STL1z_NETWORKING_MAP_NAMESPACE_BEGIN
#undef BOOST_STL1z_NETWORKING_MAP_NAMESPACE_END
