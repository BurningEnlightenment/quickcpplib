<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>QuickCppLib: quickcpplib::_xxx::detach_cast Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">QuickCppLib
   &#160;<span id="projectnumber">0.10</span>
   </div>
   <div id="projectbrief">Eliminate all the tedious hassle when making state-of-the-art C++ 14 or 17 libraries!</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacequickcpplib_1_1__xxx_1_1detach__cast.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">quickcpplib::_xxx::detach_cast Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacequickcpplib_1_1__xxx_1_1detach__cast_1_1traits"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast_1_1traits.html">traits</a></td></tr>
<tr class="memdesc:namespacequickcpplib_1_1__xxx_1_1detach__cast_1_1traits"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for user specialised traits. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacequickcpplib_1_1__xxx_1_1detach__cast_1_1detail"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2d74cd81fa791c40737aa69a31c666fc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2d74cd81fa791c40737aa69a31c666fc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a2d74cd81fa791c40737aa69a31c666fc">byte_array_reference</a> = byte(&amp;)[sizeof(T)]</td></tr>
<tr class="memdesc:a2d74cd81fa791c40737aa69a31c666fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to a byte array sized the same as <code>T</code>  <a href="#a2d74cd81fa791c40737aa69a31c666fc">More...</a><br/></td></tr>
<tr class="separator:a2d74cd81fa791c40737aa69a31c666fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f329bbab9fac876f956e30286706bbc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1f329bbab9fac876f956e30286706bbc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a1f329bbab9fac876f956e30286706bbc">const_byte_array_reference</a> = const byte(&amp;)[sizeof(T)]</td></tr>
<tr class="memdesc:a1f329bbab9fac876f956e30286706bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const reference to a byte array sized the same as <code>const T</code>  <a href="#a1f329bbab9fac876f956e30286706bbc">More...</a><br/></td></tr>
<tr class="separator:a1f329bbab9fac876f956e30286706bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af2d60e01eaca46123011af0e4af772cb"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt;!detail::is_bit_cast_valid&lt; detail::byte_array_wrapper&lt; T &gt;, T &gt;()&amp;&amp;!traits::enable_reinterpret_detach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value, bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:af2d60e01eaca46123011af0e4af772cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#aacf6c619b7e656b816b5b38aa5c2af2e">QUICKCPPLIB_NODISCARD</a> <br class="typebreak"/>
constexpr <a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a2d74cd81fa791c40737aa69a31c666fc">byte_array_reference</a><br class="typebreak"/>
&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#af2d60e01eaca46123011af0e4af772cb">detach_cast</a> (const T &amp;,...) noexcept</td></tr>
<tr class="memdesc:af2d60e01eaca46123011af0e4af772cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches a live object into its detached byte representation, ending the lifetime of the input object, and beginning the lifetime of an array of byte sized exactly the size of the input object at the same memory location, which is returned. All references to the input object become INVALID. Any use of the input object after detachment has occurred is illegal!  <a href="#af2d60e01eaca46123011af0e4af772cb">More...</a><br/></td></tr>
<tr class="separator:af2d60e01eaca46123011af0e4af772cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ffdacf2b4279bb27c3b0aa49643454"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt;!detail::is_bit_cast_valid&lt; T, detail::byte_array_wrapper&lt; T &gt;&gt;()&amp;&amp;!traits::enable_reinterpret_attach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value, bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:a87ffdacf2b4279bb27c3b0aa49643454"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#aacf6c619b7e656b816b5b38aa5c2af2e">QUICKCPPLIB_NODISCARD</a> constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a87ffdacf2b4279bb27c3b0aa49643454">attach_cast</a> (<a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a1f329bbab9fac876f956e30286706bbc">const_byte_array_reference</a>&lt; T &gt; &amp;,...) noexcept</td></tr>
<tr class="memdesc:a87ffdacf2b4279bb27c3b0aa49643454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reattaches a previously detached object, beginning the lifetime of the output object, and ending the lifetime of the input array of byte. All references to the input byte array become INVALID. Any use of the input array after attachment has occurred is illegal!  <a href="#a87ffdacf2b4279bb27c3b0aa49643454">More...</a><br/></td></tr>
<tr class="separator:a87ffdacf2b4279bb27c3b0aa49643454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3584374c371d6b8a174acaf0cce1dea"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt; detail::is_bit_cast_valid&lt; detail::byte_array_wrapper&lt; T &gt;, T &gt;()&amp;&amp;!traits::enable_reinterpret_detach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value, bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:af3584374c371d6b8a174acaf0cce1dea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#aacf6c619b7e656b816b5b38aa5c2af2e">QUICKCPPLIB_NODISCARD</a> <br class="typebreak"/>
constexpr <a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a2d74cd81fa791c40737aa69a31c666fc">byte_array_reference</a><br class="typebreak"/>
&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#af3584374c371d6b8a174acaf0cce1dea">detach_cast</a> (T &amp;v) noexcept</td></tr>
<tr class="memdesc:af3584374c371d6b8a174acaf0cce1dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches a non-const bit-castable object into its detached non-const byte representation, ending the lifetime of the input object. Defined behaviour in C++ 20 (though only the clang compiler currently reliably does not copy the byte array twice. GCC avoids the memory copy for small objects, MSVC always copies the byte array twice).  <a href="#af3584374c371d6b8a174acaf0cce1dea">More...</a><br/></td></tr>
<tr class="separator:af3584374c371d6b8a174acaf0cce1dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe4b5d53fca26b6df32293215c3c561"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt; detail::is_bit_cast_valid&lt; const detail::byte_array_wrapper&lt; T &gt;, const T &gt;()&amp;&amp;!traits::enable_reinterpret_detach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value, bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:aafe4b5d53fca26b6df32293215c3c561"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#aacf6c619b7e656b816b5b38aa5c2af2e">QUICKCPPLIB_NODISCARD</a> <br class="typebreak"/>
constexpr <br class="typebreak"/>
<a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a1f329bbab9fac876f956e30286706bbc">const_byte_array_reference</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#aafe4b5d53fca26b6df32293215c3c561">detach_cast</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:aafe4b5d53fca26b6df32293215c3c561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches a const bit-castable object into its detached const byte representation, ending the lifetime of the input object. Defined behaviour in C++ 20 (though only the clang compiler currently reliably does not copy the byte array twice. GCC avoids the memory copy for small objects, MSVC always copies the byte array twice).  <a href="#aafe4b5d53fca26b6df32293215c3c561">More...</a><br/></td></tr>
<tr class="separator:aafe4b5d53fca26b6df32293215c3c561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5f11591b289f45c80f0b2321400ddf"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt; detail::is_bit_cast_valid&lt; T, detail::byte_array_wrapper&lt; T &gt;&gt;()&amp;&amp;!traits::enable_reinterpret_attach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value, bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:a4f5f11591b289f45c80f0b2321400ddf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#aacf6c619b7e656b816b5b38aa5c2af2e">QUICKCPPLIB_NODISCARD</a> constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a4f5f11591b289f45c80f0b2321400ddf">attach_cast</a> (<a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a2d74cd81fa791c40737aa69a31c666fc">byte_array_reference</a>&lt; T &gt; v) noexcept</td></tr>
<tr class="memdesc:a4f5f11591b289f45c80f0b2321400ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a non-const bit-castable object from its detached non-const byte representation, ending the lifetime of the input array. Defined behaviour in C++ 20 (though only the clang compiler currently reliably does not copy the byte array twice. GCC avoids the memory copy for small objects, MSVC always copies the byte array twice).  <a href="#a4f5f11591b289f45c80f0b2321400ddf">More...</a><br/></td></tr>
<tr class="separator:a4f5f11591b289f45c80f0b2321400ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4f92eda602b7c11fe0907acc295ee6"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt; detail::is_bit_cast_valid&lt; T, const detail::byte_array_wrapper&lt; T &gt;&gt;()&amp;&amp;!traits::enable_reinterpret_attach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value &amp;&amp;std::is_const&lt; T &gt;::value, bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:a7d4f92eda602b7c11fe0907acc295ee6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#aacf6c619b7e656b816b5b38aa5c2af2e">QUICKCPPLIB_NODISCARD</a> <br class="typebreak"/>
constexpr const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a7d4f92eda602b7c11fe0907acc295ee6">attach_cast</a> (<a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a1f329bbab9fac876f956e30286706bbc">const_byte_array_reference</a>&lt; T &gt; v) noexcept</td></tr>
<tr class="memdesc:a7d4f92eda602b7c11fe0907acc295ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a const bit-castable object from its detached const byte representation, ending the lifetime of the input array. Defined behaviour in C++ 20 (though only the clang compiler currently reliably does not copy the byte array twice. GCC avoids the memory copy for small objects, MSVC always copies the byte array twice).  <a href="#a7d4f92eda602b7c11fe0907acc295ee6">More...</a><br/></td></tr>
<tr class="separator:a7d4f92eda602b7c11fe0907acc295ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2998b0daf2b135ce576019f0eedb5b1"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt;!detail::is_bit_cast_valid&lt; const T, const detail::byte_array_wrapper&lt; T &gt;&gt;()&amp;&amp;traits::enable_reinterpret_attach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value &amp;&amp;std::is_const&lt; T &gt;::value, bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:ae2998b0daf2b135ce576019f0eedb5b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#aacf6c619b7e656b816b5b38aa5c2af2e">QUICKCPPLIB_NODISCARD</a> constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#ae2998b0daf2b135ce576019f0eedb5b1">attach_cast</a> (<a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a1f329bbab9fac876f956e30286706bbc">const_byte_array_reference</a>&lt; T &gt; v) noexcept</td></tr>
<tr class="memdesc:ae2998b0daf2b135ce576019f0eedb5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret casts a non-const byte representation into a non-const object. Pure undefined behaviour. Available only if <code>traits::enable_reinterpret_attach_cast&lt;T&gt;</code> is true for the type.  <a href="#ae2998b0daf2b135ce576019f0eedb5b1">More...</a><br/></td></tr>
<tr class="separator:ae2998b0daf2b135ce576019f0eedb5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a2d74cd81fa791c40737aa69a31c666fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a2d74cd81fa791c40737aa69a31c666fc">quickcpplib::_xxx::detach_cast::byte_array_reference</a> = typedef byte (&amp;)[sizeof(T)]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A reference to a byte array sized the same as <code>T</code> </p>

</div>
</div>
<a class="anchor" id="a1f329bbab9fac876f956e30286706bbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a1f329bbab9fac876f956e30286706bbc">quickcpplib::_xxx::detach_cast::const_byte_array_reference</a> = typedef const byte (&amp;)[sizeof(T)]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A const reference to a byte array sized the same as <code>const T</code> </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af2d60e01eaca46123011af0e4af772cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt;!detail::is_bit_cast_valid&lt; detail::byte_array_wrapper&lt; T &gt;, T &gt;()&amp;&amp;!traits::enable_reinterpret_detach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value, bool &gt;::type  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#aacf6c619b7e656b816b5b38aa5c2af2e">QUICKCPPLIB_NODISCARD</a> constexpr <a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a2d74cd81fa791c40737aa69a31c666fc">byte_array_reference</a>&lt;T&gt; quickcpplib::_xxx::detach_cast::detach_cast </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detaches a live object into its detached byte representation, ending the lifetime of the input object, and beginning the lifetime of an array of byte sized exactly the size of the input object at the same memory location, which is returned. All references to the input object become INVALID. Any use of the input object after detachment has occurred is illegal! </p>
<p>Implementation notes: If the input type is bit castable, bit casting is used to implement detachment using defined behaviour in C++ 20. Otherwise <code>traits::enable_reinterpret_detach_cast&lt;T&gt;</code> is used to determine whether to implement detachment using undefined behaviour by reinterpret casting. </p>
<div class="fragment"><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;  {                                                                                                                                     <span class="comment">//</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    static_assert(!std::is_same&lt;T, T&gt;::value, <span class="stringliteral">&quot;In C++ 20, detach_cast(T) is defined behaviour only for types which are bit castable. &quot;</span>  <span class="comment">//</span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;                                              <span class="stringliteral">&quot;Set traits::enable_reinterpret_detach_cast&lt;T&gt; for specific types if you don&#39;t mind undefined behaviour.&quot;</span>);</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a87ffdacf2b4279bb27c3b0aa49643454"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt;!detail::is_bit_cast_valid&lt; T, detail::byte_array_wrapper&lt; T &gt;&gt;()&amp;&amp;!traits::enable_reinterpret_attach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value, bool &gt;::type  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#aacf6c619b7e656b816b5b38aa5c2af2e">QUICKCPPLIB_NODISCARD</a> constexpr T&amp; quickcpplib::_xxx::detach_cast::attach_cast </td>
          <td>(</td>
          <td class="paramtype">const_byte_array_reference&lt; T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reattaches a previously detached object, beginning the lifetime of the output object, and ending the lifetime of the input array of byte. All references to the input byte array become INVALID. Any use of the input array after attachment has occurred is illegal! </p>
<p>Implementation notes: If the output type is bit castable, bit casting is used to implement attachment using defined behaviour in C++ 20. Otherwise <code>traits::enable_reinterpret_attach_cast&lt;T&gt;</code> is used to determine whether to implement attachment using undefined behaviour by reinterpret casting. </p>
<div class="fragment"><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;  {                                                                                                                                     <span class="comment">//</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    static_assert(!std::is_same&lt;T, T&gt;::value, <span class="stringliteral">&quot;In C++ 20, attach_cast(T) is defined behaviour only for types which are bit castable. &quot;</span>  <span class="comment">//</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;                                              <span class="stringliteral">&quot;Set traits::enable_reinterpret_attach_cast&lt;T&gt; for specific types if you don&#39;t mind undefined behaviour.&quot;</span>);</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af3584374c371d6b8a174acaf0cce1dea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt; detail::is_bit_cast_valid&lt; detail::byte_array_wrapper&lt; T &gt;, T &gt;()&amp;&amp;!traits::enable_reinterpret_detach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value, bool &gt;::type  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#aacf6c619b7e656b816b5b38aa5c2af2e">QUICKCPPLIB_NODISCARD</a> constexpr <a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a2d74cd81fa791c40737aa69a31c666fc">byte_array_reference</a>&lt; T &gt; quickcpplib::_xxx::detach_cast::detach_cast </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detaches a non-const bit-castable object into its detached non-const byte representation, ending the lifetime of the input object. Defined behaviour in C++ 20 (though only the clang compiler currently reliably does not copy the byte array twice. GCC avoids the memory copy for small objects, MSVC always copies the byte array twice). </p>
<p>Reinterpret casts a non-const object reference into a non-const byte representation. Pure undefined behaviour. Available only if <code>traits::enable_reinterpret_detach_cast&lt;T&gt;</code> is true for the type. </p>
<div class="fragment"><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  {</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    <span class="comment">// Bit cast and copy the input object into a stack allocated byte array. This</span></div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    <span class="comment">// is defined behaviour for trivially copyable types.</span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    <span class="keyword">auto</span> buffer(<a class="code" href="namespacequickcpplib_1_1__xxx_1_1bit__cast.html#ad7fb7ca36afeecc06809df709a4db1f7">bit_cast</a>&lt;detail::byte_array_wrapper&lt;T&gt;&gt;(v));</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    <span class="comment">// Cast input reference to output reference. Using the cast reference is defined</span></div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    <span class="comment">// behaviour for a few special functions e.g. memcpy()</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    <span class="keyword">auto</span> &amp;ret = <span class="keyword">reinterpret_cast&lt;</span>byte_array_reference&lt;T&gt;<span class="keyword">&gt;</span>(v);</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    <span class="comment">// Copy the detached byte representation back over the input storage. This ends</span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    <span class="comment">// the lifetime of the input object, which is defined behaviour due to it being</span></div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    <span class="comment">// trivially copyable. The compiler now knows that the output reference does not</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    <span class="comment">// alias the same object given by the input reference.</span></div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    memcpy(&amp;ret, buffer.value, <span class="keyword">sizeof</span>(T));</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    <span class="comment">// Return a reference to the byte array representing the detached object.</span></div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    <span class="keywordflow">return</span> ret;</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;  }</div>
<div class="ttc" id="namespacequickcpplib_1_1__xxx_1_1bit__cast_html_ad7fb7ca36afeecc06809df709a4db1f7"><div class="ttname"><a href="namespacequickcpplib_1_1__xxx_1_1bit__cast.html#ad7fb7ca36afeecc06809df709a4db1f7">quickcpplib::_xxx::bit_cast::bit_cast</a></div><div class="ttdeci">constexpr To bit_cast(const From &amp;from) noexcept</div><div class="ttdoc">Bit cast emulation chosen if types are move relocating or trivally copyable, have identical size...</div><div class="ttdef"><b>Definition:</b> bit_cast.hpp:98</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aafe4b5d53fca26b6df32293215c3c561"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt; detail::is_bit_cast_valid&lt; const detail::byte_array_wrapper&lt; T &gt;, const T &gt;()&amp;&amp;!traits::enable_reinterpret_detach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value, bool &gt;::type  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#aacf6c619b7e656b816b5b38aa5c2af2e">QUICKCPPLIB_NODISCARD</a> constexpr <a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a1f329bbab9fac876f956e30286706bbc">const_byte_array_reference</a>&lt; T &gt; quickcpplib::_xxx::detach_cast::detach_cast </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detaches a const bit-castable object into its detached const byte representation, ending the lifetime of the input object. Defined behaviour in C++ 20 (though only the clang compiler currently reliably does not copy the byte array twice. GCC avoids the memory copy for small objects, MSVC always copies the byte array twice). </p>
<p>Reinterpret casts a const object reference into a const byte representation. Pure undefined behaviour. Available only if <code>traits::enable_reinterpret_detach_cast&lt;T&gt;</code> is true for the type. </p>
<div class="fragment"><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;  {</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> buffer(<a class="code" href="namespacequickcpplib_1_1__xxx_1_1bit__cast.html#ad7fb7ca36afeecc06809df709a4db1f7">bit_cast</a>&lt;<span class="keyword">const</span> detail::byte_array_wrapper&lt;T&gt;&gt;(v));</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    <span class="keyword">auto</span> &amp;ret = <span class="keyword">const_cast&lt;</span>byte_array_reference&lt;T&gt;<span class="keyword">&gt;</span>(<span class="keyword">reinterpret_cast&lt;</span>const_byte_array_reference&lt;T&gt;<span class="keyword">&gt;</span>(v));</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    memcpy(&amp;ret, buffer.value, <span class="keyword">sizeof</span>(T));</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    <span class="keywordflow">return</span> ret;</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;  }</div>
<div class="ttc" id="namespacequickcpplib_1_1__xxx_1_1bit__cast_html_ad7fb7ca36afeecc06809df709a4db1f7"><div class="ttname"><a href="namespacequickcpplib_1_1__xxx_1_1bit__cast.html#ad7fb7ca36afeecc06809df709a4db1f7">quickcpplib::_xxx::bit_cast::bit_cast</a></div><div class="ttdeci">constexpr To bit_cast(const From &amp;from) noexcept</div><div class="ttdoc">Bit cast emulation chosen if types are move relocating or trivally copyable, have identical size...</div><div class="ttdef"><b>Definition:</b> bit_cast.hpp:98</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4f5f11591b289f45c80f0b2321400ddf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt; detail::is_bit_cast_valid&lt; T, detail::byte_array_wrapper&lt; T &gt;&gt;()&amp;&amp;!traits::enable_reinterpret_attach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value, bool &gt;::type  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#aacf6c619b7e656b816b5b38aa5c2af2e">QUICKCPPLIB_NODISCARD</a> constexpr T &amp; quickcpplib::_xxx::detach_cast::attach_cast </td>
          <td>(</td>
          <td class="paramtype">byte_array_reference&lt; T &gt;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches a non-const bit-castable object from its detached non-const byte representation, ending the lifetime of the input array. Defined behaviour in C++ 20 (though only the clang compiler currently reliably does not copy the byte array twice. GCC avoids the memory copy for small objects, MSVC always copies the byte array twice). </p>
<p>Reinterpret casts a const byte representation into a const object. Pure undefined behaviour. Available only if <code>traits::enable_reinterpret_attach_cast&lt;T&gt;</code> is true for the type. </p>
<div class="fragment"><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;  {</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    <span class="comment">// Bit cast and copy the input byte array into a stack allocated object. This</span></div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    <span class="comment">// is defined behaviour for trivially copyable types.</span></div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    T temp(bit_cast&lt;T&gt;(v));</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    <span class="comment">// Cast input reference to output reference. Using the cast reference is defined</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    <span class="comment">// behaviour for a few special functions e.g. memcpy()</span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    T &amp;ret = <span class="keyword">reinterpret_cast&lt;</span>T &amp;<span class="keyword">&gt;</span>(v);</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    <span class="comment">// Trivially copyable types can be memcpy()ied, this begins lifetime in the destination</span></div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    memcpy(&amp;ret, &amp;temp, <span class="keyword">sizeof</span>(T));</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    <span class="comment">// Return a reference to the new object.</span></div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    <span class="keywordflow">return</span> ret;</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7d4f92eda602b7c11fe0907acc295ee6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt; detail::is_bit_cast_valid&lt; T, const detail::byte_array_wrapper&lt; T &gt;&gt;()&amp;&amp;!traits::enable_reinterpret_attach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value &amp;&amp;std::is_const&lt; T &gt;::value, bool &gt;::type  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#aacf6c619b7e656b816b5b38aa5c2af2e">QUICKCPPLIB_NODISCARD</a> constexpr const T&amp; quickcpplib::_xxx::detach_cast::attach_cast </td>
          <td>(</td>
          <td class="paramtype">const_byte_array_reference&lt; T &gt;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches a const bit-castable object from its detached const byte representation, ending the lifetime of the input array. Defined behaviour in C++ 20 (though only the clang compiler currently reliably does not copy the byte array twice. GCC avoids the memory copy for small objects, MSVC always copies the byte array twice). </p>
<div class="fragment"><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;  {</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    <span class="keyword">using</span> nonconst = <span class="keyword">typename</span> std::remove_const&lt;T&gt;::type;</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    T temp(bit_cast&lt;nonconst&gt;(v));</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    nonconst &amp;ret = <span class="keyword">const_cast&lt;</span>nonconst &amp;<span class="keyword">&gt;</span>(<span class="keyword">reinterpret_cast&lt;</span>T &amp;<span class="keyword">&gt;</span>(v));</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    memcpy(&amp;ret, &amp;temp, <span class="keyword">sizeof</span>(T));</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    <span class="keywordflow">return</span> ret;</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae2998b0daf2b135ce576019f0eedb5b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt;!detail::is_bit_cast_valid&lt; const T, const detail::byte_array_wrapper&lt; T &gt;&gt;()&amp;&amp;traits::enable_reinterpret_attach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value &amp;&amp;std::is_const&lt; T &gt;::value, bool &gt;::type  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#aacf6c619b7e656b816b5b38aa5c2af2e">QUICKCPPLIB_NODISCARD</a> constexpr T&amp; quickcpplib::_xxx::detach_cast::attach_cast </td>
          <td>(</td>
          <td class="paramtype">const_byte_array_reference&lt; T &gt;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinterpret casts a non-const byte representation into a non-const object. Pure undefined behaviour. Available only if <code>traits::enable_reinterpret_attach_cast&lt;T&gt;</code> is true for the type. </p>
<div class="fragment"><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;  {</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>T &amp;<span class="keyword">&gt;</span>(v);</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacequickcpplib.html">quickcpplib</a></li><li class="navelem"><a class="el" href="namespacequickcpplib_1_1__xxx.html">_xxx</a></li><li class="navelem"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html">detach_cast</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
