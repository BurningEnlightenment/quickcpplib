<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QuickCppLib: include/quickcpplib/detach_cast.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">QuickCppLib
   &#160;<span id="projectnumber">0.10</span>
   </div>
   <div id="projectbrief">Eliminate all the tedious hassle when making state-of-the-art C++ 14 - 23 libraries!</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('detach__cast_8hpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">detach_cast.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="bit__cast_8hpp.html">bit_cast.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="byte_8hpp.html">byte.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="span_8hpp.html">span.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="type__traits_8hpp.html">type_traits.hpp</a>&quot;</code><br />
<code>#include &lt;cstring&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquickcpplib_1_1__xxx_1_1detach__cast_1_1traits_1_1enable__reinterpret__detach__cast.html">quickcpplib::_xxx::detach_cast::traits::enable_reinterpret_detach_cast&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialise to true if you want to enable the reinterpret cast based implementation of <code>detach_cast()</code> for some type <code>T</code>. This introduces undefined behaviour in C++ 20.  <a href="structquickcpplib_1_1__xxx_1_1detach__cast_1_1traits_1_1enable__reinterpret__detach__cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquickcpplib_1_1__xxx_1_1detach__cast_1_1traits_1_1enable__reinterpret__attach__cast.html">quickcpplib::_xxx::detach_cast::traits::enable_reinterpret_attach_cast&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialise to true if you want to enable the reinterpret cast based implementation of <code>attach_cast()</code> for some type <code>T</code>. This introduces undefined behaviour in C++ 20.  <a href="structquickcpplib_1_1__xxx_1_1detach__cast_1_1traits_1_1enable__reinterpret__attach__cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacequickcpplib"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib.html">quickcpplib</a></td></tr>
<tr class="memdesc:namespacequickcpplib"><td class="mdescLeft">&#160;</td><td class="mdescRight">The QuickCppLib namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacequickcpplib_1_1__xxx"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx.html">quickcpplib::_xxx</a></td></tr>
<tr class="memdesc:namespacequickcpplib_1_1__xxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Per commit unique namespace to prevent different git submodule versions clashing. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacequickcpplib_1_1__xxx_1_1detach__cast"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html">quickcpplib::_xxx::detach_cast</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacequickcpplib_1_1__xxx_1_1detach__cast_1_1traits"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast_1_1traits.html">quickcpplib::_xxx::detach_cast::traits</a></td></tr>
<tr class="memdesc:namespacequickcpplib_1_1__xxx_1_1detach__cast_1_1traits"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for user specialised traits. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacequickcpplib_1_1__xxx_1_1detach__cast_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast_1_1detail.html">quickcpplib::_xxx::detach_cast::detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a5b169ff4148b0331ea5bad6347b8bafb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="detach__cast_8hpp.html#a5b169ff4148b0331ea5bad6347b8bafb">QUICKCPPLIB_DETACH_CAST_NODISCARD</a>&#160;&#160;&#160;<a class="el" href="config_8hpp.html#aacf6c619b7e656b816b5b38aa5c2af2e">QUICKCPPLIB_NODISCARD</a></td></tr>
<tr class="separator:a5b169ff4148b0331ea5bad6347b8bafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2d74cd81fa791c40737aa69a31c666fc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2d74cd81fa791c40737aa69a31c666fc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a2d74cd81fa791c40737aa69a31c666fc">quickcpplib::_xxx::detach_cast::byte_array_reference</a> = byte(&amp;)[sizeof(T)]</td></tr>
<tr class="memdesc:a2d74cd81fa791c40737aa69a31c666fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to a byte array sized the same as <code>T</code>  <a href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a2d74cd81fa791c40737aa69a31c666fc">More...</a><br /></td></tr>
<tr class="separator:a2d74cd81fa791c40737aa69a31c666fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f329bbab9fac876f956e30286706bbc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1f329bbab9fac876f956e30286706bbc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a1f329bbab9fac876f956e30286706bbc">quickcpplib::_xxx::detach_cast::const_byte_array_reference</a> = const byte(&amp;)[sizeof(T)]</td></tr>
<tr class="memdesc:a1f329bbab9fac876f956e30286706bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const reference to a byte array sized the same as <code>const T</code>  <a href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a1f329bbab9fac876f956e30286706bbc">More...</a><br /></td></tr>
<tr class="separator:a1f329bbab9fac876f956e30286706bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a30b58ed0621bafae6c207a68d639b432"><td class="memTemplParams" colspan="2">template&lt;class To , class From , typename  = decltype(  quickcpplib::_xxx ::bit_cast::bit_cast&lt;To, From&gt;(std::declval&lt;From&gt;()) )&gt; </td></tr>
<tr class="memitem:a30b58ed0621bafae6c207a68d639b432"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast_1_1detail.html#a30b58ed0621bafae6c207a68d639b432">quickcpplib::_xxx::detach_cast::detail::_is_bit_cast_valid</a> (int)</td></tr>
<tr class="separator:a30b58ed0621bafae6c207a68d639b432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4532a9128a100234391b3663c768c02"><td class="memTemplParams" colspan="2">template&lt;class To , class From &gt; </td></tr>
<tr class="memitem:ab4532a9128a100234391b3663c768c02"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast_1_1detail.html#ab4532a9128a100234391b3663c768c02">quickcpplib::_xxx::detach_cast::detail::_is_bit_cast_valid</a> (...)</td></tr>
<tr class="separator:ab4532a9128a100234391b3663c768c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62119844e67df8419307868de925874e"><td class="memTemplParams" colspan="2">template&lt;class To , class From &gt; </td></tr>
<tr class="memitem:a62119844e67df8419307868de925874e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast_1_1detail.html#a62119844e67df8419307868de925874e">quickcpplib::_xxx::detach_cast::detail::is_bit_cast_valid</a> ()</td></tr>
<tr class="separator:a62119844e67df8419307868de925874e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66379c0f8f8aac01b0720fb67ae20595"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt;(!detail::is_bit_cast_valid&lt; detail::byte_array_wrapper&lt; T &gt;, T &gt;() &amp;&amp;!traits::enable_reinterpret_detach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:a66379c0f8f8aac01b0720fb67ae20595"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="detach__cast_8hpp.html#a5b169ff4148b0331ea5bad6347b8bafb">QUICKCPPLIB_DETACH_CAST_NODISCARD</a> byte_array_reference&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a66379c0f8f8aac01b0720fb67ae20595">quickcpplib::_xxx::detach_cast::detach_cast</a> (const T &amp;,...) noexcept</td></tr>
<tr class="memdesc:a66379c0f8f8aac01b0720fb67ae20595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches a live object into its detached byte representation, ending the lifetime of the input object, and beginning the lifetime of an array of byte sized exactly the size of the input object at the same memory location, which is returned. All references to the input object become INVALID. Any use of the input object after detachment has occurred is illegal!  <a href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a66379c0f8f8aac01b0720fb67ae20595">More...</a><br /></td></tr>
<tr class="separator:a66379c0f8f8aac01b0720fb67ae20595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2372691416d28e04e57372210e1d4d5"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt;(!detail::is_bit_cast_valid&lt; T, detail::byte_array_wrapper&lt; T &gt;&gt;() &amp;&amp;!traits::enable_reinterpret_attach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:aa2372691416d28e04e57372210e1d4d5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="detach__cast_8hpp.html#a5b169ff4148b0331ea5bad6347b8bafb">QUICKCPPLIB_DETACH_CAST_NODISCARD</a> T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#aa2372691416d28e04e57372210e1d4d5">quickcpplib::_xxx::detach_cast::attach_cast</a> (const_byte_array_reference&lt; T &gt; &amp;,...) noexcept</td></tr>
<tr class="memdesc:aa2372691416d28e04e57372210e1d4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reattaches a previously detached object, beginning the lifetime of the output object, and ending the lifetime of the input array of byte. All references to the input byte array become INVALID. Any use of the input array after attachment has occurred is illegal!  <a href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#aa2372691416d28e04e57372210e1d4d5">More...</a><br /></td></tr>
<tr class="separator:aa2372691416d28e04e57372210e1d4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe64ef4acec61364d15e8cf8ab8e3a15"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt;(detail::is_bit_cast_valid&lt; detail::byte_array_wrapper&lt; T &gt;, T &gt;() &amp;&amp;!traits::enable_reinterpret_detach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:afe64ef4acec61364d15e8cf8ab8e3a15"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="detach__cast_8hpp.html#a5b169ff4148b0331ea5bad6347b8bafb">QUICKCPPLIB_DETACH_CAST_NODISCARD</a> byte_array_reference&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#afe64ef4acec61364d15e8cf8ab8e3a15">quickcpplib::_xxx::detach_cast::detach_cast</a> (T &amp;v, detail::bit_castable_overload={}) noexcept</td></tr>
<tr class="memdesc:afe64ef4acec61364d15e8cf8ab8e3a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches a non-const bit-castable object into its detached non-const byte representation, ending the lifetime of the input object. Defined behaviour in C++ 20 (though only the clang compiler currently reliably does not copy the byte array twice. GCC avoids the memory copy for small objects, MSVC always copies the byte array twice).  <a href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#afe64ef4acec61364d15e8cf8ab8e3a15">More...</a><br /></td></tr>
<tr class="separator:afe64ef4acec61364d15e8cf8ab8e3a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577acdec6671cf545989fa6b9f86ad8d"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt;(detail::is_bit_cast_valid&lt; const detail::byte_array_wrapper&lt; T &gt;, const T &gt;() &amp;&amp;!traits::enable_reinterpret_detach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:a577acdec6671cf545989fa6b9f86ad8d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="detach__cast_8hpp.html#a5b169ff4148b0331ea5bad6347b8bafb">QUICKCPPLIB_DETACH_CAST_NODISCARD</a> const_byte_array_reference&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a577acdec6671cf545989fa6b9f86ad8d">quickcpplib::_xxx::detach_cast::detach_cast</a> (const T &amp;v, detail::bit_castable_overload={}) noexcept</td></tr>
<tr class="memdesc:a577acdec6671cf545989fa6b9f86ad8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches a const bit-castable object into its detached const byte representation, ending the lifetime of the input object. Defined behaviour in C++ 20 (though only the clang compiler currently reliably does not copy the byte array twice. GCC avoids the memory copy for small objects, MSVC always copies the byte array twice).  <a href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a577acdec6671cf545989fa6b9f86ad8d">More...</a><br /></td></tr>
<tr class="separator:a577acdec6671cf545989fa6b9f86ad8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93c3b1332a77ad05a45505363efc4fa"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt;(detail::is_bit_cast_valid&lt; T, detail::byte_array_wrapper&lt; T &gt;&gt;() &amp;&amp;!traits::enable_reinterpret_attach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value &amp;&amp;!std::is_const&lt; T &gt;::value), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:ae93c3b1332a77ad05a45505363efc4fa"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="detach__cast_8hpp.html#a5b169ff4148b0331ea5bad6347b8bafb">QUICKCPPLIB_DETACH_CAST_NODISCARD</a> T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#ae93c3b1332a77ad05a45505363efc4fa">quickcpplib::_xxx::detach_cast::attach_cast</a> (byte_array_reference&lt; T &gt; v, detail::bit_castable_overload={}) noexcept</td></tr>
<tr class="memdesc:ae93c3b1332a77ad05a45505363efc4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a non-const bit-castable object from its detached non-const byte representation, ending the lifetime of the input array. Defined behaviour in C++ 20 (though only the clang compiler currently reliably does not copy the byte array twice. GCC avoids the memory copy for small objects, MSVC always copies the byte array twice).  <a href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#ae93c3b1332a77ad05a45505363efc4fa">More...</a><br /></td></tr>
<tr class="separator:ae93c3b1332a77ad05a45505363efc4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae966fe799280f914fe218e3c9954e400"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt;(detail::is_bit_cast_valid&lt; T, const detail::byte_array_wrapper&lt; T &gt;&gt;() &amp;&amp;!traits::enable_reinterpret_attach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value &amp;&amp;std::is_const&lt; T &gt;::value), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:ae966fe799280f914fe218e3c9954e400"><td class="memTemplItemLeft" align="right" valign="top">constexpr const <a class="el" href="detach__cast_8hpp.html#a5b169ff4148b0331ea5bad6347b8bafb">QUICKCPPLIB_DETACH_CAST_NODISCARD</a> T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#ae966fe799280f914fe218e3c9954e400">quickcpplib::_xxx::detach_cast::attach_cast</a> (const_byte_array_reference&lt; T &gt; v, detail::bit_castable_overload={}) noexcept</td></tr>
<tr class="memdesc:ae966fe799280f914fe218e3c9954e400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a const bit-castable object from its detached const byte representation, ending the lifetime of the input array. Defined behaviour in C++ 20 (though only the clang compiler currently reliably does not copy the byte array twice. GCC avoids the memory copy for small objects, MSVC always copies the byte array twice).  <a href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#ae966fe799280f914fe218e3c9954e400">More...</a><br /></td></tr>
<tr class="separator:ae966fe799280f914fe218e3c9954e400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0615bc9f7919c888ff6c59ea79b343e1"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt;(!detail::is_bit_cast_valid&lt; detail::byte_array_wrapper&lt; T &gt;, T &gt;() &amp;&amp;traits::enable_reinterpret_detach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:a0615bc9f7919c888ff6c59ea79b343e1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="detach__cast_8hpp.html#a5b169ff4148b0331ea5bad6347b8bafb">QUICKCPPLIB_DETACH_CAST_NODISCARD</a> byte_array_reference&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a0615bc9f7919c888ff6c59ea79b343e1">quickcpplib::_xxx::detach_cast::detach_cast</a> (T &amp;v, detail::reinterpret_cast_overload={}) noexcept</td></tr>
<tr class="memdesc:a0615bc9f7919c888ff6c59ea79b343e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret casts a non-const object reference into a non-const byte representation. Pure undefined behaviour. Available only if <code>traits::enable_reinterpret_detach_cast&lt;T&gt;</code> is true for the type.  <a href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a0615bc9f7919c888ff6c59ea79b343e1">More...</a><br /></td></tr>
<tr class="separator:a0615bc9f7919c888ff6c59ea79b343e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad919c006b40f3b08e3ef11040976b51d"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt;(!detail::is_bit_cast_valid&lt; const detail::byte_array_wrapper&lt; T &gt;, const T &gt;() &amp;&amp;traits::enable_reinterpret_detach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:ad919c006b40f3b08e3ef11040976b51d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="detach__cast_8hpp.html#a5b169ff4148b0331ea5bad6347b8bafb">QUICKCPPLIB_DETACH_CAST_NODISCARD</a> const_byte_array_reference&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#ad919c006b40f3b08e3ef11040976b51d">quickcpplib::_xxx::detach_cast::detach_cast</a> (const T &amp;v, detail::reinterpret_cast_overload={}) noexcept</td></tr>
<tr class="memdesc:ad919c006b40f3b08e3ef11040976b51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret casts a const object reference into a const byte representation. Pure undefined behaviour. Available only if <code>traits::enable_reinterpret_detach_cast&lt;T&gt;</code> is true for the type.  <a href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#ad919c006b40f3b08e3ef11040976b51d">More...</a><br /></td></tr>
<tr class="separator:ad919c006b40f3b08e3ef11040976b51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0440025f70394449f8c2ca006140d10f"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt;(!detail::is_bit_cast_valid&lt; T, detail::byte_array_wrapper&lt; T &gt;&gt;() &amp;&amp;traits::enable_reinterpret_attach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value &amp;&amp;!std::is_const&lt; T &gt;::value), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:a0440025f70394449f8c2ca006140d10f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="detach__cast_8hpp.html#a5b169ff4148b0331ea5bad6347b8bafb">QUICKCPPLIB_DETACH_CAST_NODISCARD</a> T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a0440025f70394449f8c2ca006140d10f">quickcpplib::_xxx::detach_cast::attach_cast</a> (byte_array_reference&lt; T &gt; v, detail::reinterpret_cast_overload={}) noexcept</td></tr>
<tr class="memdesc:a0440025f70394449f8c2ca006140d10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret casts a const byte representation into a const object. Pure undefined behaviour. Available only if <code>traits::enable_reinterpret_attach_cast&lt;T&gt;</code> is true for the type.  <a href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#a0440025f70394449f8c2ca006140d10f">More...</a><br /></td></tr>
<tr class="separator:a0440025f70394449f8c2ca006140d10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bf8c291df20c587773cf0d333be9d0"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt;(!detail::is_bit_cast_valid&lt; const T, const detail::byte_array_wrapper&lt; T &gt;&gt;() &amp;&amp;traits::enable_reinterpret_attach_cast&lt; typename std::decay&lt; T &gt;::type &gt;::value &amp;&amp;std::is_const&lt; T &gt;::value), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:ab9bf8c291df20c587773cf0d333be9d0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="detach__cast_8hpp.html#a5b169ff4148b0331ea5bad6347b8bafb">QUICKCPPLIB_DETACH_CAST_NODISCARD</a> T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#ab9bf8c291df20c587773cf0d333be9d0">quickcpplib::_xxx::detach_cast::attach_cast</a> (const_byte_array_reference&lt; T &gt; v, detail::reinterpret_cast_overload={}) noexcept</td></tr>
<tr class="memdesc:ab9bf8c291df20c587773cf0d333be9d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret casts a non-const byte representation into a non-const object. Pure undefined behaviour. Available only if <code>traits::enable_reinterpret_attach_cast&lt;T&gt;</code> is true for the type.  <a href="namespacequickcpplib_1_1__xxx_1_1detach__cast.html#ab9bf8c291df20c587773cf0d333be9d0">More...</a><br /></td></tr>
<tr class="separator:ab9bf8c291df20c587773cf0d333be9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a5b169ff4148b0331ea5bad6347b8bafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b169ff4148b0331ea5bad6347b8bafb">&#9670;&nbsp;</a></span>QUICKCPPLIB_DETACH_CAST_NODISCARD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QUICKCPPLIB_DETACH_CAST_NODISCARD&#160;&#160;&#160;<a class="el" href="config_8hpp.html#aacf6c619b7e656b816b5b38aa5c2af2e">QUICKCPPLIB_NODISCARD</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_d1498f5694bf8fd9ebfffeb3ee9c2787.html">quickcpplib</a></li><li class="navelem"><a class="el" href="detach__cast_8hpp.html">detach_cast.hpp</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
