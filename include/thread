/* This is an automatically generated bindings file. Don't modify it! */
#if !defined(BOOST_STL11_MAP_START_NAMESPACE) || !defined(BOOST_STL11_MAP_END_NAMESPACE)
#error You need to define BOOST_STL11_MAP_START_NAMESPACE and BOOST_STL11_MAP_END_NAMESPACE to use this header file
#endif
#include "boostmacros.hpp"
#include <thread>
BOOST_STL11_MAP_START_NAMESPACE
using std::float_denorm_style;
  using std::denorm_indeterminate;
  using std::denorm_absent;
  using std::denorm_present;
using std::float_round_style;
  using std::round_indeterminate;
  using std::round_toward_zero;
  using std::round_to_nearest;
  using std::round_toward_infinity;
  using std::round_toward_neg_infinity;
template<class _Tp1> using auto_ptr_ref = std::auto_ptr_ref<_Tp1>;
template<class _Tp> using weak_ptr = std::weak_ptr<_Tp>;
template<class _Tp> using shared_ptr = std::shared_ptr<_Tp>;
using bad_weak_ptr = std::bad_weak_ptr;
template<class _Tp, class _Dp> using unique_ptr = std::unique_ptr<_Tp, _Dp>;
template<class _Tp> using default_delete = std::default_delete<_Tp>;
template<class _Tp> using auto_ptr = std::auto_ptr<_Tp>;
template<class type_parameter_0_0> using auto_ptr = std::auto_ptr<type_parameter_0_0>;
template<class _OutputIterator, class _Tp> using raw_storage_iterator = std::raw_storage_iterator<_OutputIterator, _Tp>;
template<class _Alloc> using allocator_traits = std::allocator_traits<_Alloc>;
using bad_function_call = std::bad_function_call;
template<class _Tp> using is_placeholder = std::is_placeholder<_Tp>;
template<class _Tp> using is_bind_expression = std::is_bind_expression<_Tp>;
using allocator_arg_t = std::allocator_arg_t;
using range_error = std::range_error;
using out_of_range = std::out_of_range;
using domain_error = std::domain_error;
using logic_error = std::logic_error;
template<class _Tp> using hash = std::hash<_Tp>;
template<class _CharT> using messages_byname = std::messages_byname<_CharT>;
template<class _Tp> using add_cv = std::add_cv<_Tp>;
using random_access_iterator_tag = std::random_access_iterator_tag;
template<class _R1, class _R2> using ratio_equal = std::ratio_equal<_R1, _R2>;
template<class _R1, class _R2> using ratio_greater = std::ratio_greater<_R1, _R2>;
template<class _Tp> using add_const = std::add_const<_Tp>;
template<class _CharT, class _InIter> using num_get = std::num_get<_CharT, _InIter>;
template<class _Tp> using reference_wrapper = std::reference_wrapper<_Tp>;
template<class _Tp> using add_pointer = std::add_pointer<_Tp>;
template<class _Tp> using logical_or = std::logical_or<_Tp>;
template<class _Tp, std::size_t _1> using array = std::array<_Tp, _1>;
template<bool _0, class _Tp> using enable_if = std::enable_if<_0, _Tp>;
template<std::size_t _0, std::size_t _1> using aligned_storage = std::aligned_storage<_0, _1>;
template<class _Tp> using bit_and = std::bit_and<_Tp>;
template<class _Tp> using remove_extent = std::remove_extent<_Tp>;
template<class _Tp> using make_signed = std::make_signed<_Tp>;
template<class _CharT, class _Traits> using basic_istream = std::basic_istream<_CharT, _Traits>;
template<class _Tp> using make_unsigned = std::make_unsigned<_Tp>;
template<class _Tp> using underlying_type = std::underlying_type<_Tp>;
template<class _Tp> using add_volatile = std::add_volatile<_Tp>;
template<class _Tp> using remove_volatile = std::remove_volatile<_Tp>;
template<class _Tp> using has_virtual_destructor = std::has_virtual_destructor<_Tp>;
template<class _Tp> using has_trivial_copy_constructor = std::has_trivial_copy_constructor<_Tp>;
template<class _Tp> using common_type = std::common_type<_Tp>;
template<class type_parameter_0_0> using is_function = std::is_function<type_parameter_0_0>;
template<class _Tp> using enable_shared_from_this = std::enable_shared_from_this<_Tp>;
template<class _Tp> using is_literal_type = std::is_literal_type<_Tp>;
template<class _Tp> using divides = std::divides<_Tp>;
template<class _Tp> using is_trivially_destructible = std::is_trivially_destructible<_Tp>;
template<class _Tp> using is_nothrow_move_assignable = std::is_nothrow_move_assignable<_Tp>;
template<class _Tp, class _Up> using is_nothrow_assignable = std::is_nothrow_assignable<_Tp, _Up>;
template<class _Tp> using is_copy_assignable = std::is_copy_assignable<_Tp>;
template<class _Tp> using modulus = std::modulus<_Tp>;
template<class _Tp, class _Args> using is_nothrow_constructible = std::is_nothrow_constructible<_Tp, _Args>;
template<std::size_t _0, class _Tp> using tuple_element = std::tuple_element<_0, _Tp>;
template<class _CharT, class _Traits, class _Alloc> using basic_string = std::basic_string<_CharT, _Traits, _Alloc>;
template<class type_parameter_0_0> using rank = std::rank<type_parameter_0_0>;
template<class _Tp> using is_nothrow_move_constructible = std::is_nothrow_move_constructible<_Tp>;
template<class _Tp> using is_nothrow_destructible = std::is_nothrow_destructible<_Tp>;
template<class _From, class _To> using is_convertible = std::is_convertible<_From, _To>;
template<class _Tp> using is_default_constructible = std::is_default_constructible<_Tp>;
template<class type_parameter_0_0> using is_volatile = std::is_volatile<type_parameter_0_0>;
template<class _Tp> using is_enum = std::is_enum<_Tp>;
template<class _Tp> using is_member_function_pointer = std::is_member_function_pointer<_Tp>;
template<class _Arg1, class _Arg2, class _Result> using binary_function = std::binary_function<_Arg1, _Arg2, _Result>;
template<class _Base, class _Derived> using is_base_of = std::is_base_of<_Base, _Derived>;
template<class type_parameter_0_0, class type_parameter_0_1> using is_base_of = std::is_base_of<type_parameter_0_0, type_parameter_0_1>;
template<class _Tp> using is_member_object_pointer = std::is_member_object_pointer<_Tp>;
template<class _Tp> using is_destructible = std::is_destructible<_Tp>;
template<class _CharT, class _InIter> using time_get = std::time_get<_CharT, _InIter>;
template<class _Tp> using is_move_constructible = std::is_move_constructible<_Tp>;
template<class _Tp> using is_arithmetic = std::is_arithmetic<_Tp>;
template<class _Tp, _Tp _1> using integral_constant = std::integral_constant<_Tp, _1>;
template<class _Tp> using is_fundamental = std::is_fundamental<_Tp>;
template<bool _0, class _Iftrue, class _Iffalse> using conditional = std::conditional<_0, _Iftrue, _Iffalse>;
template<bool _0, class type_parameter_0_1, class type_parameter_0_2> using conditional = std::conditional<_0, type_parameter_0_1, type_parameter_0_2>;
template<class _Signature> using result_of = std::result_of<_Signature>;
template<class _Tp> using is_polymorphic = std::is_polymorphic<_Tp>;
template<class _Tp> using remove_all_extents = std::remove_all_extents<_Tp>;
template<class type_parameter_0_0> using remove_all_extents = std::remove_all_extents<type_parameter_0_0>;
template<class _Tp> using is_null_pointer = std::is_null_pointer<_Tp>;
template<class _Tp> using add_rvalue_reference = std::add_rvalue_reference<_Tp>;
template<class type_parameter_0_0> using add_rvalue_reference = std::add_rvalue_reference<type_parameter_0_0>;
template<class _Tp> using allocator = std::allocator<_Tp>;
template<class type_parameter_0_0> using allocator = std::allocator<type_parameter_0_0>;
template<class _Tp> using is_move_assignable = std::is_move_assignable<_Tp>;
template<class _CharT, class _Traits> using basic_ios = std::basic_ios<_CharT, _Traits>;
template<class _CharT> using collate = std::collate<_CharT>;
template<class _Tp, class _Up> using is_assignable = std::is_assignable<_Tp, _Up>;
template<class _Tp> using is_pointer = std::is_pointer<_Tp>;
template<class _Tp> using is_object = std::is_object<_Tp>;
template<class _Tp> using is_empty = std::is_empty<_Tp>;
template<class type_parameter_0_0, unsigned int _1> using extent = std::extent<type_parameter_0_0, _1>;
template<class _Tp> using remove_cv = std::remove_cv<_Tp>;
template<class type_parameter_0_0> using remove_cv = std::remove_cv<type_parameter_0_0>;
template<intmax_t _0, intmax_t _1> using ratio = std::ratio<_0, _1>;
using output_iterator_tag = std::output_iterator_tag;
template<class _Tp> using is_trivial = std::is_trivial<_Tp>;
using forward_iterator_tag = std::forward_iterator_tag;
using runtime_error = std::runtime_error;
template<class _Container> using insert_iterator = std::insert_iterator<_Container>;
template<class _R1, class _R2> using ratio_not_equal = std::ratio_not_equal<_R1, _R2>;
template<class _Tp> using is_abstract = std::is_abstract<_Tp>;
template<class type_parameter_0_0, class type_parameter_0_1> using is_same = std::is_same<type_parameter_0_0, type_parameter_0_1>;
template<class _Tp> using is_nothrow_copy_assignable = std::is_nothrow_copy_assignable<_Tp>;
template<class _Tp> using is_copy_constructible = std::is_copy_constructible<_Tp>;
template<class type_parameter_0_0> using is_lvalue_reference = std::is_lvalue_reference<type_parameter_0_0>;
template<class type_parameter_0_0> using is_array = std::is_array<type_parameter_0_0>;
template<class _Tp> using is_pod = std::is_pod<_Tp>;
template<class _Tp> using is_nothrow_copy_constructible = std::is_nothrow_copy_constructible<_Tp>;
template<class _Ret, class _Tp, class _Arg> using const_mem_fun1_t = std::const_mem_fun1_t<_Ret, _Tp, _Arg>;
template<class _Tp> using is_void = std::is_void<_Tp>;
template<class _Tp> using is_scalar = std::is_scalar<_Tp>;
template<class _CharT> using messages = std::messages<_CharT>;
template<class _Tp> using equal_to = std::equal_to<_Tp>;
template<class _Tp> using has_trivial_copy_assign = std::has_trivial_copy_assign<_Tp>;
template<class _CharT, class _OutIter> using money_put = std::money_put<_CharT, _OutIter>;
template<class _CharT, bool _1> using moneypunct_byname = std::moneypunct_byname<_CharT, _1>;
template<class _Tp> using is_standard_layout = std::is_standard_layout<_Tp>;
template<class _Tp> using add_lvalue_reference = std::add_lvalue_reference<_Tp>;
template<class _Predicate> using binary_negate = std::binary_negate<_Predicate>;
template<class _Container> using back_insert_iterator = std::back_insert_iterator<_Container>;
template<class _CharT, class _OutIter> using time_put_byname = std::time_put_byname<_CharT, _OutIter>;
template<class _Tp> using is_compound = std::is_compound<_Tp>;
template<class _Tp> using is_reference = std::is_reference<_Tp>;
template<class _CharT, class _Traits> using basic_streambuf = std::basic_streambuf<_CharT, _Traits>;
using messages_base = std::messages_base;
template<class _Tp> using alignment_of = std::alignment_of<_Tp>;
template<class _Tp> using is_signed = std::is_signed<_Tp>;
template<class _Tp> using is_unsigned = std::is_unsigned<_Tp>;
template<class _R1, class _R2> using ratio_less_equal = std::ratio_less_equal<_R1, _R2>;
template<class _Tp> using remove_reference = std::remove_reference<_Tp>;
template<class type_parameter_0_0> using remove_reference = std::remove_reference<type_parameter_0_0>;
template<class _CharT, class _Traits> using istreambuf_iterator = std::istreambuf_iterator<_CharT, _Traits>;
template<class _Tp> using remove_pointer = std::remove_pointer<_Tp>;
template<class _Ret, class _Tp> using const_mem_fun_ref_t = std::const_mem_fun_ref_t<_Ret, _Tp>;
template<class _Ret, class _Tp, class _Arg> using mem_fun1_ref_t = std::mem_fun1_ref_t<_Ret, _Tp, _Arg>;
using ctype_base = std::ctype_base;
template<class _CharT, bool _1> using moneypunct = std::moneypunct<_CharT, _1>;
using overflow_error = std::overflow_error;
template<class _Tp, class _Args> using is_constructible = std::is_constructible<_Tp, _Args>;
template<class _Signature> using function = std::function<_Signature>;
template<class _R1, class _R2> using ratio_greater_equal = std::ratio_greater_equal<_R1, _R2>;
template<class _CharT, class _Traits> using basic_fstream = std::basic_fstream<_CharT, _Traits>;
template<class _Tp> using is_member_pointer = std::is_member_pointer<_Tp>;
template<class type_parameter_0_0> using is_member_pointer = std::is_member_pointer<type_parameter_0_0>;
template<class _CharT> using ctype_byname = std::ctype_byname<_CharT>;
template<class _Tp> using plus = std::plus<_Tp>;
template<class _Tp> using less_equal = std::less_equal<_Tp>;
template<class _Tp> using minus = std::minus<_Tp>;
template<class _CharT, class _Traits> using basic_filebuf = std::basic_filebuf<_CharT, _Traits>;
template<class _Tp> using negate = std::negate<_Tp>;
template<class _Tp> using not_equal_to = std::not_equal_to<_Tp>;
template<class _CharT> using numpunct = std::numpunct<_CharT>;
template<class _Arg, class _Result> using unary_function = std::unary_function<_Arg, _Result>;
template<class _Tp> using greater = std::greater<_Tp>;
template<class _Tp> using less = std::less<_Tp>;
template<class _Tp> using greater_equal = std::greater_equal<_Tp>;
template<class _Tp> using logical_and = std::logical_and<_Tp>;
template<class type_parameter_0_0> using is_const = std::is_const<type_parameter_0_0>;
template<class _Tp> using decay = std::decay<_Tp>;
template<class _Tp> using bit_or = std::bit_or<_Tp>;
template<class _Tp> using bit_not = std::bit_not<_Tp>;
using piecewise_construct_t = std::piecewise_construct_t;
template<class _Predicate> using unary_negate = std::unary_negate<_Predicate>;
template<class _Iterator> using reverse_iterator = std::reverse_iterator<_Iterator>;
template<class _Tp> using numeric_limits = std::numeric_limits<_Tp>;
template<class _Arg, class _Result> using pointer_to_unary_function = std::pointer_to_unary_function<_Arg, _Result>;
template<class _Arg1, class _Arg2, class _Result> using pointer_to_binary_function = std::pointer_to_binary_function<_Arg1, _Arg2, _Result>;
template<class _CharT, class _InIter> using money_get = std::money_get<_CharT, _InIter>;
template<class _Ret, class _Tp> using mem_fun_t = std::mem_fun_t<_Ret, _Tp>;
template<class _Ret, class _Tp> using const_mem_fun_t = std::const_mem_fun_t<_Ret, _Tp>;
template<class _Tp> using owner_less = std::owner_less<_Tp>;
template<class _Tp> using logical_not = std::logical_not<_Tp>;
using bidirectional_iterator_tag = std::bidirectional_iterator_tag;
template<class _Iterator> using move_iterator = std::move_iterator<_Iterator>;
template<class _Ret, class _Tp, class _Arg> using mem_fun1_t = std::mem_fun1_t<_Ret, _Tp, _Arg>;
template<class _Ret, class _Tp, class _Arg> using const_mem_fun1_ref_t = std::const_mem_fun1_ref_t<_Ret, _Tp, _Arg>;
template<class _Tp> using is_nothrow_default_constructible = std::is_nothrow_default_constructible<_Tp>;
template<class _Operation> using binder1st = std::binder1st<_Operation>;
template<class _Operation> using binder2nd = std::binder2nd<_Operation>;
template<class _CharT, class _OutIter> using time_put = std::time_put<_CharT, _OutIter>;
template<class _Elements> using tuple = std::tuple<_Elements>;
template<class type_parameter_0_0> using tuple = std::tuple<type_parameter_0_0>;
template<class _CharT, class _Traits> using basic_ofstream = std::basic_ofstream<_CharT, _Traits>;
template<class _T1, class _T2> using pair = std::pair<_T1, _T2>;
template<class _E> using initializer_list = std::initializer_list<_E>;
template<class _Iterator> using iterator_traits = std::iterator_traits<_Iterator>;
template<class _Tp> using tuple_size = std::tuple_size<_Tp>;
using underflow_error = std::underflow_error;
template<class _Tp, class _Alloc> using uses_allocator = std::uses_allocator<_Tp, _Alloc>;
template<class type_parameter_0_0, class type_parameter_0_1> using uses_allocator = std::uses_allocator<type_parameter_0_0, type_parameter_0_1>;
template<class _R1, class _R2> using ratio_less = std::ratio_less<_R1, _R2>;
template<class _Tp> using has_trivial_default_constructor = std::has_trivial_default_constructor<_Tp>;
template<class _CharT> using char_traits = std::char_traits<_CharT>;
using input_iterator_tag = std::input_iterator_tag;
template<class _Category, class _Tp, class _Distance, class _Pointer, class _Reference> using iterator = std::iterator<_Category, _Tp, _Distance, _Pointer, _Reference>;
template<class _CharT> using collate_byname = std::collate_byname<_CharT>;
using length_error = std::length_error;
template<class _Tp> using is_union = std::is_union<_Tp>;
template<class _Ptr> using pointer_traits = std::pointer_traits<_Ptr>;
template<class _Tp> using remove_const = std::remove_const<_Tp>;
template<class _Container> using front_insert_iterator = std::front_insert_iterator<_Container>;
template<class _Ret, class _Tp> using mem_fun_ref_t = std::mem_fun_ref_t<_Ret, _Tp>;
template<class _CharT, class _Traits> using ostreambuf_iterator = std::ostreambuf_iterator<_CharT, _Traits>;
template<class _Tp> using is_class = std::is_class<_Tp>;
template<class _StateT> using fpos = std::fpos<_StateT>;
template<class _Tp> using bit_xor = std::bit_xor<_Tp>;
using ios_base = std::ios_base;
template<class _CharT, class _Traits> using basic_ostream = std::basic_ostream<_CharT, _Traits>;
template<class _CharT, class _Traits> using basic_iostream = std::basic_iostream<_CharT, _Traits>;
template<class _CharT, class _Traits, class _Alloc> using basic_stringbuf = std::basic_stringbuf<_CharT, _Traits, _Alloc>;
template<class _CharT, class _Traits, class _Alloc> using basic_istringstream = std::basic_istringstream<_CharT, _Traits, _Alloc>;
template<class _CharT, class _Traits, class _Alloc> using basic_ostringstream = std::basic_ostringstream<_CharT, _Traits, _Alloc>;
template<class _Tp> using is_integral = std::is_integral<_Tp>;
template<class _CharT, class _Traits, class _Alloc> using basic_stringstream = std::basic_stringstream<_CharT, _Traits, _Alloc>;
template<class type_parameter_0_0> using is_rvalue_reference = std::is_rvalue_reference<type_parameter_0_0>;
template<class _CharT, class _Traits> using basic_ifstream = std::basic_ifstream<_CharT, _Traits>;
using locale = std::locale;
template<class _Tp> using is_floating_point = std::is_floating_point<_Tp>;
template<class _CharT> using ctype = std::ctype<_CharT>;
using codecvt_base = std::codecvt_base;
template<class _Tp> using multiplies = std::multiplies<_Tp>;
template<class _InternT, class _ExternT, class _StateT> using codecvt = std::codecvt<_InternT, _ExternT, _StateT>;
template<class _InternT, class _ExternT, class _StateT> using codecvt_byname = std::codecvt_byname<_InternT, _ExternT, _StateT>;
template<class _CharT, class _OutIter> using num_put = std::num_put<_CharT, _OutIter>;
using thread = std::thread;
template<class _CharT> using numpunct_byname = std::numpunct_byname<_CharT>;
using time_base = std::time_base;
template<class _CharT, class _InIter> using time_get_byname = std::time_get_byname<_CharT, _InIter>;
using invalid_argument = std::invalid_argument;
using money_base = std::money_base;
BOOST_STL11_MAP_END_NAMESPACE
