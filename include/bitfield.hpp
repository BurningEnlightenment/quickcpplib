/* bitfield.hpp
Yet another C++ 11 constexpr bitfield
(C) 2016 Niall Douglas http://www.nedprod.com/
File Created: Aug 2016


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef BOOSTLITE_BITFIELD_HPP
#define BOOSTLITE_BITFIELD_HPP

#include "boost/config.hpp"
#include "config.hpp"

BOOSTLITE_NAMESPACE_BEGIN

namespace bitfield
{
  /*!
  \brief Constexpr typesafe bitwise flags support

  Usage:
  \code
  BOOSTLITE_BITFIELD_BEGIN(flag)
  {
    flag1 = 1 << 0,
    flag2 = 1 << 1,
    ...
  }
  BOOSTLITE_BITFIELD_END(flag)
  ...
  flag myflags = flag::flag1|flag::flag2;
  if(myflags & flag::flag1) ...
  if(!myflags) ...
  // This intentionally fails to compile:
  // if(myflags && flag::flag2)
  //
  // That is because of operator precedence difficulties in say:
  // if(myflags && flag::flag1 && myflags && flag::flag2)
  //
  // This works fine though:
  if((myflags & flag::flag1) || (myflags & flag::flag2)) ...
  \endcode
  */
  template <class Enum> struct bitfield : public Enum
  {
    //! The C style enum type which represents flags in this bitfield
    using enum_type = typename Enum::enum_type;
    //! The type which the C style enum implicitly converts to
    using underlying_type = std::underlying_type_t<enum_type>;

  private:
    underlying_type _value;

  public:
    //! Default construct to all bits zero
    constexpr bitfield() noexcept : _value(0) {}
    //! Implicit construction from the C style enum
    constexpr bitfield(enum_type v) noexcept : _value(v) {}
    //! Implicit construction from the underlying type of the C enum
    constexpr bitfield(underlying_type v) noexcept : _value(v) {}

    //! Permit explicit casting to the underlying type
    explicit constexpr operator underlying_type() const noexcept { return _value; }
    //! Test for non-zeroness
    explicit constexpr operator bool() const noexcept { return !!_value; }
    //! Test for zeroness
    constexpr bool operator!() const noexcept { return !_value; }

    //! Test for equality
    constexpr bool operator==(bitfield o) const noexcept { return _value == o._value; }
    //! Test for equality
    constexpr bool operator==(enum_type o) const noexcept { return _value == o; }
    //! Test for inequality
    constexpr bool operator!=(bitfield o) const noexcept { return _value != o._value; }
    //! Test for inequality
    constexpr bool operator!=(enum_type o) const noexcept { return _value != o; }

    //! Performs a bitwise NOT
    constexpr bitfield operator~() const noexcept { return bitfield(~_value); }
    //! Performs a bitwise AND
    constexpr bitfield operator&(bitfield o) const noexcept { return bitfield(_value & o._value); }
    //! Performs a bitwise AND
    constexpr bitfield operator&(enum_type o) const noexcept { return bitfield(_value & o); }
    //! Performs a bitwise AND
    BOOSTLITE_CONSTEXPR bitfield &operator&=(bitfield o) noexcept
    {
      _value &= o._value;
      return *this;
    }
    //! Performs a bitwise AND
    BOOSTLITE_CONSTEXPR bitfield &operator&=(enum_type o) noexcept
    {
      _value &= o;
      return *this;
    }
    //! Trap incorrect use of logical AND
    template <class T> bool operator&&(T) noexcept = delete;
    //! Trap incorrect use of logical OR
    // template <class T> bool operator||(T) noexcept = delete;
    //! Performs a bitwise OR
    constexpr bitfield operator|(bitfield o) const noexcept { return bitfield(_value | o._value); }
    //! Performs a bitwise OR
    constexpr bitfield operator|(enum_type o) const noexcept { return bitfield(_value | o); }
    //! Performs a bitwise OR
    BOOSTLITE_CONSTEXPR bitfield &operator|=(bitfield o) noexcept
    {
      _value |= o._value;
      return *this;
    }
    //! Performs a bitwise OR
    BOOSTLITE_CONSTEXPR bitfield &operator|=(enum_type o) noexcept
    {
      _value |= o;
      return *this;
    }
    //! Performs a bitwise XOR
    constexpr bitfield operator^(bitfield o) const noexcept { return bitfield(_value ^ o._value); }
    //! Performs a bitwise XOR
    constexpr bitfield operator^(enum_type o) const noexcept { return bitfield(_value ^ o); }
    //! Performs a bitwise XOR
    BOOSTLITE_CONSTEXPR bitfield &operator^=(bitfield o) noexcept
    {
      _value ^= o._value;
      return *this;
    }
    //! Performs a bitwise XOR
    BOOSTLITE_CONSTEXPR bitfield &operator^=(enum_type o) noexcept
    {
      _value ^= o;
      return *this;
    }
  };

//! Begins a typesafe bitfield
#define BOOSTLITE_BITFIELD_BEGIN(type)                                                                                                                                                                                                                                                                                         \
  \
struct type##_base                                                                                                                                                                                                                                                                                                             \
  \
{                                                                                                                                                                                                                                                                                                                         \
  enum enum_type : unsigned

//! Ends a typesafe bitfield
#define BOOSTLITE_BITFIELD_END(type)                                                                                                                                                                                                                                                                                           \
  \
;                                                                                                                                                                                                                                                                                                                         \
  }                                                                                                                                                                                                                                                                                                                            \
  ;                                                                                                                                                                                                                                                                                                                            \
  \
using type = BOOSTLITE_NAMESPACE::bitfield::bitfield<type##_base>;
}

BOOSTLITE_NAMESPACE_END
#endif
